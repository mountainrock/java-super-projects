<questionbank group="Core Java">
	<category name="Basics">
		<qa id="1" rating="1">			<question><![CDATA[q:What do you understand by a variable?]]></question>
			<answer><![CDATA[Variable is a named memory location that can be easily referred in the program. A variable is just a container for holding data and is accesible through a reference.]]></answer>
		</qa>
		<qa id="2" rating="2">			<question><![CDATA[q:What is the Java API?]]></question>
			<answer><![CDATA[The Java API(Application Programming Interface) is the set of classes included with the Java Development Environment. These classes are written using the Java language and run on the JVM. The Java API includes everything from collection classes to GUI classes]]></answer>
		</qa>
		<qa id="3" rating="2">			<question><![CDATA[q:What is JVM,JRE, JDK?]]></question>
			<answer><![CDATA[The Java Virtual Machine(JVM) is the software that can be ported onto various hardware-based platforms.The JVM executes instructions that a Java compiler generates.<br/><br/>
The JRE is the Java Runtime Environment consisting of the JVM, the Java libraries, and all other components necessary to run Java applications and applets, but does not contain any development tools such as a compiler or a debugger<br/><br/>
JDK contains software development tools which are used to compile and run the Java program.<br/><br/>
Both JDK and JRE contains the JVM. .]]></answer>
		</qa>
		<qa id="4" rating="2
----">			<question><![CDATA[q:What if <br/>
1. Main method is declared as private?<br/> 
2. Static modifier is removed from the signature of the main method?<br/> 
3. I do not provide the String array as the argument to the method?]]></question>
			<answer><![CDATA[<ol>
<li> The program compiles properly but at runtime it will give "Main method not public" error message.</li>
<li> Program compiles.But at runtime throws an error "NoSuchMethodError"</li>
<li> The program works fine.</li>
</ol>]]></answer>
		</qa>
		<qa id="5" rating="2">			<question><![CDATA[q:What is meant by pass by reference and pass by value in Java?]]></question>
			<answer><![CDATA[Pass by reference means, passing the address itself(like pointers) rather than passing the value. 
Pass by value means passing a copy of the value. Java uses pass by value.]]></answer>
		</qa>
		<qa id="6" rating="2">			<question><![CDATA[q:If you're overriding the method equals() of an object, which other method you might also consider?]]></question>
			<answer><![CDATA[hashCode()]]></answer>
		</qa>
		<qa id="7" rating="2">			<question><![CDATA[q:What is Byte Code?]]></question>
			<answer><![CDATA[All Java programs are compiled into class files that contain bytecodes. 
Java bytecode is produced by the Java compiler and executed by the JVM.
Bytecode is the intermediate representation of Java programs just as assembly code is the intermediate representation of C or C++ programs
Java bytecode is one of the things that make it possible for Java code to run on many different platforms.]]></answer>
		</qa>
		<qa id="8" rating="1">			<question><![CDATA[q:Expain the reason for each keyword of public static void main(String args[])?]]></question>
			<answer><![CDATA[<ul>
<li><b>public main(..)</b> is the first method called by java environment when a program is executed so it has to accessible from java environment. Hence the access specifier has to be public. </li>
<li><b>static:</b> Java environment should be able to call this method without creating an instance of the class , so this method must be declared as static. </li>
<li><b>void:</b> main does not return anything so the return type must be void </li>
<li><b>String args[]</b> The argument String indicates the argument type which is given at the command line and <b>args</b> is an array for string given during command line. </li>
</ul>]]></answer>
		</qa>
		<qa id="9" rating="2">			<question><![CDATA[q:What are the differences between == and .equals()?]]></question>
			<answer><![CDATA[The == operator compares two objects to determine if they are present in the same memory location. 
It is possible for two String objects to have the same value, but located in different areas of memory.
== compares references while .equals compares contents. <br/><br/>

The method public boolean equals(Object obj) is provided by the Object class and can be overridden. <br/>
The default implementation uses the equality operator == to compare the object. String, BitSet, Date, and File override the equals() method. 
For two String objects, value equality means that they contain the same character sequence. Eg:
<pre>
...
public static void main(String[] args) {
  String s1 = "abc";
  String s2 = s1;
  String s5 = "abc";
  String s3 = new String("abc");
  String s4 = new String("abc");
  S.o.p("== comparison : " + (s1 == s5));
  S.o.p("== comparison : " + (s1 == s2));
  S.o.p("Using equals method : " + s1.equals(s2));
  S.o.p("== comparison : " + s3 == s4);
  S.o.p("Using equals method : " + s3.equals(s4));
 }
...

<b>Output</b>
== comparison : true
== comparison : true
Using equals method : true
== comparison : false
Using equals method : true
</pre>]]></answer>
		</qa>
		<qa id="10" rating="2">			<question><![CDATA[q:What is final, finalize() and finally? 
  What does it mean that a class or member is final?]]></question>
			<answer><![CDATA[<ul><li><b>final</b> - Variables defined in an interface are implicitly final. A final class can't be extended i.e., final class may not be subclassed. This is done for security reasons with basic classes like String and Integer. It also allows the compiler to make some optimizations, and makes thread safety a little easier to achieve. A final method can't be overridden when its class is inherited. You can't change value of a final variable (is a constant) </li>
   <li><b>finally</b> - a key word used in exception handling and will be executed whether or not an exception is thrown. For example, closing of open connections is done in the finally method. </li>
   <li><b>finalize</b> - helps in garbage collection. finalize() method is used just before an object is destroyed and garbage collected</li></ul>]]></answer>
		</qa>
		<qa id="11" rating="2">			<question><![CDATA[q:Why there are no global variables in Java?]]></question>
			<answer><![CDATA[Global variables are globally accessible. Java encapsulates data and makes it available through methods. Every variable in Java must be declared within a class.]]></answer>
		</qa>
		<qa id="12" rating="1">			<question><![CDATA[q:How to convert String to Number in java program?]]></question>
			<answer><![CDATA[The valueOf() function of Integer class is is used to convert string to Number. Here is the code Eg: 
<pre>
String numString = "1000"; 
int id=Integer.valueOf(numString).intValue(); 
</pre>]]></answer>
		</qa>
		<qa id="13" rating="1">			<question><![CDATA[q:What is the difference between a while statement and a do statement?]]></question>
			<answer><![CDATA[A while statement (pre test) checks at the beginning of a loop to see whether the next loop iteration should occur. 
A do while statement (post test) checks at the end of a loop. 
The do statement will always execute the loop body at least once.]]></answer>
		</qa>
		<qa id="14" rating="1">			<question><![CDATA[q:Describe the principles of OOPS.]]></question>
			<answer><![CDATA[There are three main principles: 
<ul>
<li>Polymorphism</li>
<li>Inheritance </li>
<li>Encapsulation </li>
</li>
</ul>]]></answer>
		</qa>
		<qa id="15" rating="2">			<question><![CDATA[q:Explain the Inheritance principle.]]></question>
			<answer><![CDATA[Inheritance is the process by which one object acquires the properties and behaviour of another object. Inheritance allows well-tested methods 
to be reused and enables changes to be made once and have effect in all relevant places.]]></answer>
		</qa>
		<qa id="16" rating="1">			<question><![CDATA[q:What do you understand by casting in java language? What are the types of casting?]]></question>
			<answer><![CDATA[The process of converting one data type to another is called Casting. There are two types of casting in Java; these are implicit casting and explicit casting.]]></answer>
		</qa>
		<qa id="17" rating="2">			<question><![CDATA[q:What is implicit and explicit casting?]]></question>
			<answer><![CDATA[Implicit casting is the process of simply assigning one entity to another without any transformation guidance to the compiler. This type of casting is not permitted in all kinds of transformations and may not work for all scenarios. 
Explicit casting in the process in which the complier are specifically informed about transforming the object.
<pre>
 eg: 
 int i = 1000, k =100.20; 
 long j = i; //Implicit 
 int j = (int) i; //Explicit  
</pre>]]></answer>
		</qa>
		<qa id="18" rating="2">			<question><![CDATA[q:What do you understand by downcasting?]]></question>
			<answer><![CDATA[The process of Downcasting refers to the casting from a general to a more specific type, i.e. casting down the hierarchy.]]></answer>
		</qa>
		<qa id="19" rating="1">			<question><![CDATA[q:Is sizeof a keyword in java?]]></question>
			<answer><![CDATA[The sizeof method is not a keyword.]]></answer>
		</qa>
		<qa id="20" rating="1">			<question><![CDATA[q:What is a native method?]]></question>
			<answer><![CDATA[A native method is a method that is implemented in a language other than Java.]]></answer>
		</qa>
		<qa id="21" rating="1">			<question><![CDATA[q:In S.o.p(), what is System, out and println?]]></question>
			<answer><![CDATA[System is a predefined final class, out is a PrintStream object and println is a built-in overloaded method in the out object.]]></answer>
		</qa>
		<qa id="22" rating="2">			<question><![CDATA[q:Explain Polymorphism? Explain the different forms of Polymorphism.]]></question>
			<answer><![CDATA[Polymorphism simply means one name many forms. Polymorphism enables one entity to be used as a general category for different types of actions. The specific action is determined by the exact nature of the situation.<br/> 
In java there are two type of polymorphism: compile time polymorphism (overloading) and runtime polymorphism (overriding).

Polymorphism exists in three distinct forms in Java: 
 <ul><li> Method overloading </li>
 <li> Method overriding through inheritance </li>
 <li>Method overriding through the Java interface </li></ul>]]></answer>
		</qa>
		<qa id="23" rating="2">			<question><![CDATA[q:Explain Encapsulation.]]></question>
			<answer><![CDATA[Encapsulation is a process of binding or wrapping the variables and the method that operates on them into a single entity. This keeps the data safe from outside interface and misuse. Objects allow methods to be encapsulated with their data to reduce potential interference. 
Encapsulation may be used by creating 'get' and 'set' methods in a class which are used to access the fields of the object. Typically the fields are made private while the get and set methods are public. Encapsulation provides data security by data hiding.]]></answer>
		</qa>
		<qa id="24" rating="2">			<question><![CDATA[q:What are Java Access modifiers? 
 What is the difference between public, private, protected and default Access Specifiers?]]></question>
			<answer><![CDATA[Access specifiers are keywords that determine the type of access to the member of a class. These keywords are for allowing 
 privileges to parts of a program such as methods and variables. These are: 
 <ul><li>Public : accessible to all classes </li>
 <li>Protected : accessible to the classes within the same package and any subclasses. </li>
 <li>Private : accessible only to the class to which they belong </li>
 <li>Default : accessible to the class to which they belong and to subclasses within the same package</li></ul>]]></answer>
		</qa>
		<qa id="25" rating="1">			<question><![CDATA[q:Which class is the superclass of every class?]]></question>
			<answer><![CDATA[Object.]]></answer>
		</qa>
		<qa id="26" rating="2">			<question><![CDATA[q:Name primitive Java types.]]></question>
			<answer><![CDATA[The 8 primitive types are byte, char, short, int, long, float, double, and boolean.]]></answer>
		</qa>
		<qa id="27" rating="2">			<question><![CDATA[q:What is the purpose of static variable and method?]]></question>
			<answer><![CDATA[A <b>static variable</b> is associated with the class as a whole rather than with specific instances of a class. Each object has only one copy per class, no matter how many objects are created from it.<br/><br/>
A <b>static method</b> is a method that belongs to the class rather than any object of the class and doesn't apply to an object or even require that any objects of the class have been instantiated. Static methods are implicitly final, because overriding is done based on the type of the object, and static methods are attached to a class, not an object. A static method in a superclass can be shadowed by another static method in a subclass, as long as the original method was not declared final. However, you can't override a static method with a non-static method. In other words, you can't change a static method into an instance method in a subclass.]]></answer>
		</qa>
		<qa id="28" rating="2">			<question><![CDATA[q:What is the difference between the boolean & operator and the && operator?]]></question>
			<answer><![CDATA[If an expression involving the boolean & operator is evaluated, both operands are evaluated, whereas the && operator is a short circuit operator. When an expression involving the && operator is evaluated, the first operand is evaluated. If the first operand returns a value of true then the second operand is evaluated. If the first operand evaluates to false, the evaluation of the second operand is skipped.]]></answer>
		</qa>
		<qa id="29" rating="2">			<question><![CDATA[q:How does Java handle integer overflows and underflows?]]></question>
			<answer><![CDATA[Java does not give any explicit notifications of arithmetic underflow or overflow.   For example,integer operations will just wrap around if you 
let the operands get too big.<br/>

Floating-point operations will not wrap around, but they won't throw an exception either.  If a floating point operation overflows, the result value is  floating-point infinity.  Similarly, if it underflows,then the result will be 0.0..]]></answer>
		</qa>
		<qa id="30" rating="1">			<question><![CDATA[q:What is the difference between declaring a variable and defining a variable?]]></question>
			<answer><![CDATA[In declaration we only mention the type of the variable and its name without initializing it. Defining means declaration + initialization.<br/>
E.g. String s; is just a declaration while String s = new String ("bob"); is a definition.]]></answer>
		</qa>
		<qa id="31" rating="2">			<question><![CDATA[q:What type of parameter passing does Java support?]]></question>
			<answer><![CDATA[In Java the arguments (primitives and objects) are always passed by value. With objects, the object reference itself is passed by value and so both the original reference and parameter copy both refer to the same object.]]></answer>
		</qa>
		<qa id="32" rating="2">			<question><![CDATA[q:What do you understand by numeric promotion?]]></question>
			<answer><![CDATA[The Numeric promotion is the conversion of a smaller numeric type to a larger numeric type, so that integral and floating-point operations may take place. In the numerical promotion process the byte, char, and short values are converted to int values. The int values are also converted to long values, if necessary. The long and float values are converted to double values, as required.]]></answer>
		</qa>
		<qa id="33" rating="2">			<question><![CDATA[q:When is static variable and static block loaded in Java?]]></question>
			<answer><![CDATA[Static variable are loaded when classloader brings the class to the JVM. It is not necessary that an object has to be created. Static variables will be allocated memory space when they have been loaded. The code in a static block is loaded/executed only once i.e. when the class is first initialized. A class can have any number of static blocks. Static block is not member of a class, they do not have a return statement and they cannot be called directly and Cannot contain this or super. They are primarily used to initialize static fields.]]></answer>
		</qa>
		<qa id="34" rating="1">			<question><![CDATA[q:Explain working of Java Virtual Machine (JVM)?]]></question>
			<answer><![CDATA[Java compiler first converts .java file into .class byte code file.Java Virtual Machine interprets the byte code into the machine code depending upon the underlying operating system and hardware combination. It is responsible for all the things like garbage collection, array bounds checking, etc.
The JVM is called "virtual" because it provides a machine interface that does not depend on the underlying operating system and machine hardware architecture. This independence from hardware and operating system is a cornerstone of the write-once run-anywhere value of Java programs]]></answer>
		</qa>
		<qa id="35" rating="2">			<question><![CDATA[q:How can I swap two variables without using a third variable?]]></question>
			<answer><![CDATA[<b>Method 1 </b>: 
Add two variables and assign the value into First variable. Subtract the Second value with the result Value. and assign to Second variable. Subtract the Result of First Variable With Result of Second Variable and Assign to First Variable
<pre>
int a=5,b=10;
a=a+b; 
b=a-b; 
a=a-b;
</pre><br/>
<b>Method 2 </b>: use an XOR swap. 
<pre> 
 int a = 5; int b = 10; 
 a = a ^ b; 
 b = a ^ b; 
 a = a ^ b; 
 </pre>]]></answer>
		</qa>
		<qa id="36" rating="2">			<question><![CDATA[q:What is reflection API? How are they implemented?]]></question>
			<answer><![CDATA[Reflection is the process of introspecting the features and state of a class at runtime. 
This is supported using Reflection API with built-in classes like Class, Method, Fields, Constructors etc. 
Eg: Using Java Reflection API we can get the class name, by using the getName method.]]></answer>
		</qa>
		<qa id="37" rating="2">			<question><![CDATA[q:Does JVM maintain a cache by itself?]]></question>
			<answer><![CDATA[Yes, the JVM maintains a cache by itself. It creates the Objects on the heap, but references to those objects are on the STACK.]]></answer>
		</qa>
		<qa id="38" rating="2">			<question><![CDATA[q:What is phantom memory?]]></question>
			<answer><![CDATA[Phantom memory is false memory. Memory that does not exist in reality.]]></answer>
		</qa>
		<qa id="39" rating="2">			<question><![CDATA[q:Can a method be static and synchronized?]]></question>
			<answer><![CDATA[A static method can be synchronized. If you do so, the JVM will obtain a lock on the java.lang.Class instance associated with the object. It is similar to saying: 
synchronized(XYZ.class) { 
}]]></answer>
		</qa>
		<qa id="40" rating="2">			<question><![CDATA[q:What is difference between String and StringTokenizer?]]></question>
			<answer><![CDATA[A StringTokenizer is utility class used to break up string. String is immutable while StringTokenizer is not
<pre>
Eg: 
 StringTokenizer st = null;
 st = new StringTokenizer("Hello World"); 
while (st.hasMoreTokens()) { 
  S.o.p(st.nextToken()); 
} 
 Output:Hello World
</pre>]]></answer>
		</qa>
		<qa id="41" rating="3">			<question><![CDATA[q: Does java support multiple interitance? Why?]]></question>
			<answer><![CDATA[Java doesnt support multiple inheritance but it provide a way through which it can enact it. 
Consider the scenario is C++
<pre>
Class A{
  public void add(){
  // some text
  }
}

Class B{

 public void add(){
  // some text
 }
}

Class C extends A,B{
  public static void main(String arg[]){

  C objC = new C();
  objC.add(); //problem, compiler gets confused 
  //and cant decide to call Class A or B method.
}
</pre>
This problem is called <b>Diamond problem</b>.

This problem in java is taken care with the use of interfaces

In Java similar problem would look like:
<pre>
interface A{
	add();
}

interface B{
	add();
}

class C implements A,B{

 add(){
  // doesnt matter which interface it belong to
 }
}
</pre>]]></answer>
		</qa>
		<qa id="42" rating="3">			<question><![CDATA[q:What is difference between instanceof and isInstance(Object obj)?]]></question>
			<answer><![CDATA[Differences are as follows:<br/>
1. instanceof is a reserved word of Java, but isInstance(Object obj) is a method of java.lang.Class.<br/>
2. instanceof method is used to check the type of an object which are known at compile time and isInstance() could only be called on class, say instance of java.lang.Class.<br/>
<pre>
if (obj instanceof MyType) {
...
}else if (MyType.class.isInstance(obj)) {
...
}
</pre>
3) instanceof is used of identify whether the object is type of a particular class or its subclass but isInstance(obj) is used to identify object of a particular class.<br/>]]></answer>
		</qa>
		<qa id="43" rating="3">			<question><![CDATA[q: Explain how Java supports pass by value?]]></question>
			<answer><![CDATA[Java passes the references by value just like any other parameter. This means the references passed to the method are actually copies of the original references. Thus method manipulation will alter the objects, since the references point to the original objects. However setting the object reference to null or any other objectreference in the method will not be affected once it exits it as the object is passed by value.

<pre>
Eg:
 public void tricky(Point arg1, Point arg2)
 {
   arg1.x = 100;
   arg1.y = 100;
   Point temp = arg1;
   arg1 = arg2;
   arg2 = temp;
 }
 public static void main(String [] args)
 {
   Point pnt1 = new Point(0,0);
   Point pnt2 = new Point(0,0);
   S.o.p("X: " + pnt1.x + " Y: " +pnt1.y); 
   S.o.p("X: " + pnt2.x + " Y: " +pnt2.y);
   S.o.p(" ");
   tricky(pnt1,pnt2);
   S.o.p("X: " + pnt1.x + " Y:" + pnt1.y); 
   S.o.p("X: " + pnt2.x + " Y: " +pnt2.y); 
 }

OutPut:
X: 0 Y: 0
X: 0 Y: 0
X: 100 Y: 100
X: 0 Y: 0
</pre>
The method successfully alters the value of pnt1, even though it is passed by value; however, a swap of pnt1 and pnt2 fails! This is the major source of confusion. In the main() method, pnt1 and pnt2 are nothing more than object references. When you pass pnt1 and pnt2 to the tricky() method, Java passes the references by value just like any other parameter. This means the references passed to the method are actually copies of the original references.]]></answer>
		</qa>
		<qa id="44" rating="2">			<question><![CDATA[q: What is memory leak?]]></question>
			<answer><![CDATA[A memory leak is where an unreferenced object that will never be used again still hangs around in memory and doesnt get garbage collected.]]></answer>
		</qa>
		<qa id="45" rating="3">			<question><![CDATA[q:How to find the size of an object?]]></question>
			<answer><![CDATA[The heap size of objects can be found using : Runtime.totalMemory()-Runtime.freeMemory() .]]></answer>
		</qa>
		<qa id="46" rating="1">			<question><![CDATA[q:What if I write static public void instead of public static void?]]></question>
			<answer><![CDATA[Program compiles and runs properly.]]></answer>
		</qa>
		<qa id="47" rating="2">			<question><![CDATA[q:What is the GregorianCalendar,ResourceBundle,Locale class?]]></question>
			<answer><![CDATA[The GregorianCalendar provides support for traditional Western calendars. 
 The ResourceBundle class is used to store locale-specific resources that can be loaded by a program to tailor the program's appearance to the particular locale in which it is being run.
 The Locale class is used to tailor a program output to the conventions of a particular geographic, political, or cultural region.]]></answer>
		</qa>
		<qa id="48" rating="1">			<question><![CDATA[q:What is the first argument of the String array in main method? How can one prove that the array is not null but empty?]]></question>
			<answer><![CDATA[The String array is empty. It does not have any element. This is unlike C/C++ where the first element by default is the program name. If we do not provide any arguments on the command line, then the String array of main method will be empty but not null. 
 Print array.length. It will print 0. That means it is empty. But if it would have been null then it would have thrown a NullPointerException on attempting to print array.length.]]></answer>
		</qa>
		<qa id="49" rating="1">			<question><![CDATA[q:Can an application have multiple classes having main method?]]></question>
			<answer><![CDATA[Yes. While starting the application we mention the class name to be run. The JVM will look for the main method only in the class whose name you have mentioned. Hence there is not conflict amongst the multiple classes having main method.]]></answer>
		</qa>
		<qa id="50" rating="2">			<question><![CDATA[q:Can I have multiple main methods in the same class?]]></question>
			<answer><![CDATA[We can have multiple overloaded main methods but there can be only one main method with the following signature : 
public static void main(String[] args) {} 
  No the program fails to compile. The compiler says that the main method is already defined in the class.]]></answer>
		</qa>
	</category>
	<category name="Classes and objects">
		<qa id="51" rating="1">			<question><![CDATA[q:What is the difference between an Interface and an Abstract class?]]></question>
			<answer><![CDATA[1. An abstract class can have instance methods that implement a default behavior. An Interface can only declare constants and instance methods, but cannot implement default behavior and all methods are implicitly abstract. <br/><br/>
2. An interface has all public members and no implementation. An abstract class is a class which may have the usual flavors of class members (private, protected, etc.), but has some abstract methods.]]></answer>
		</qa>
		<qa id="52" rating="2">			<question><![CDATA[q:  What restrictions are placed on method overloading?]]></question>
			<answer><![CDATA[Two methods may not have the same name and argument list.]]></answer>
		</qa>
		<qa id="53" rating="2">			<question><![CDATA[q:  What is the difference between String and StringBuffer?]]></question>
			<answer><![CDATA[String objects are immutable whereas StringBuffer objects are not. StringBuffer unlike Strings support growable and modifiable strings.]]></answer>
		</qa>
		<qa id="54" rating="2">			<question><![CDATA[q:  Can a private method of a superclass be declared within a subclass?]]></question>
			<answer><![CDATA[Sure. A private field or method or inner class belongs to its declared class and hides from its subclasses. 
 There is no way for private stuff to have a runtime overloading or overriding (polymorphism) features.]]></answer>
		</qa>
		<qa id="55" rating="2">			<question><![CDATA[q: What is the difference between a constructor and a method? How can a subclass call a method or a constructor defined in a superclass?]]></question>
			<answer><![CDATA[1. A constructor has the same name as the class and has no return type and is called using new operator to create an instance of class. They are only called once. Methods can be called many times and has its own name, a return type and is invoked using the dot operator. <br/><br/>
2. Constructor will be automatically invoked when an object is created whereas method has to be called explicitly. <br/><br/>
3. super.method(); is used to call a super class method from a sub class. To call a constructor of the super class, we use the super(); statement as the first line of the subclass's constructor.]]></answer>
		</qa>
		<qa id="56" rating="2">			<question><![CDATA[q:  Can a top-level class be private or protected?]]></question>
			<answer><![CDATA[No. A top-level class cannot be private or protected. It can have either "public" or no modifier. If it does not have a modifier it is supposed to have a default access. If a top level class is declared as private/protected the compiler will complain that the "modifier private is not allowed here".]]></answer>
		</qa>
		<qa id="57" rating="2">			<question><![CDATA[q:  Where and how can you use a private constructor?]]></question>
			<answer><![CDATA[Private constructor can be used if you do not want any other class to instantiate the class. This concept is generally used in Singleton Design Pattern. The instantiation of such classes is done from a static public method.]]></answer>
		</qa>
		<qa id="58" rating="1">			<question><![CDATA[q:  How are this() and super() used with constructors?]]></question>
			<answer><![CDATA[this() is used to invoke a constructor of the same class. super() is used to invoke a superclass constructor.]]></answer>
		</qa>
		<qa id="59" rating="2">			<question><![CDATA[q:  What is Method Overriding? What restrictions are placed on method overriding?]]></question>
			<answer><![CDATA[When a class defines a method using the same name, return type, and argument list as that of a method in its superclass, the method in the subclass is said to override the method present in the Superclass. When the method is invoked for an object of the class, it is the new definition of the method that is called, and not the method definition from superclass. 
 Restrictions placed on method overriding 
<ul>
<li>Overridden methods must have the same name, argument list, and return type. </li>
<li>The overriding method may not limit the access of the method it overrides. Methods may be overridden to be more public, not more private. </li>
<li>The overriding method may not throw any exceptions that may not be thrown by the overridden method.</li>
</ul>]]></answer>
		</qa>
		<qa id="60" rating="2">			<question><![CDATA[q: Differentiate between a Class and an Object?]]></question>
			<answer><![CDATA[The Object class is the highest-level class in the Java class hierarchy. The Class class is used to represent the classes and interfaces that are loaded by a Java program. The Class class is used to obtain information about an object's design. A Class is only a definition or prototype of real life object. Whereas an object is an instance or living representation of real life object. Every object belongs to a class and every class contains one or more related objects.]]></answer>
		</qa>
		<qa id="61" rating="2">			<question><![CDATA[q: What is difference between overloading and overriding?]]></question>
			<answer><![CDATA[<b>Method overloading</b>: When 2 or more methods in a class have the same method names with different arguments, it is said to be method overloading. Overloading does not block inheritance from the superclass. Overloaded methods must have different method signatures but does not consider the return types.<br/><br/>
  <b>Method overriding</b> : When a method in a class has the same method name with same arguments as that of the superclass, 
 it is said to be method overriding. Overriding blocks inheritance from the superclass. Overridden methods must have same signature.<br/><br/> 
 
 Overloading and overriding are different aspects of polymorphism. <br/><br/>
 Overloading - static/early binding polymorphism(compile time):  <br/><br/>
 Overriding - dynamic/late binding polymorphism(runtime)]]></answer>
		</qa>
		<qa id="62" rating="2">			<question><![CDATA[q:  If a class is declared without any access modifiers, where may the class be accessed?]]></question>
			<answer><![CDATA[A class that is declared without any access modifiers is said to have package or default access. This means that the class can only be accessed by other classes and interfaces that are defined within the same package.]]></answer>
		</qa>
		<qa id="63" rating="2">			<question><![CDATA[q: Explain protected and default access modifiers?]]></question>
			<answer><![CDATA[The protected modifier specifies that the member can only be accessed within its own package (as with package-private) and, in addition, by a subclass of its class in another package.
For default - the class can only be accessed by other classes and interfaces that are defined within the same package.]]></answer>
		</qa>
		<qa id="64" rating="2">			<question><![CDATA[q:  Does a class inherit the constructors of its superclass?]]></question>
			<answer><![CDATA[A class does not inherit constructors from any of its super classes. However constructor chaining invokes the constructor in super class.]]></answer>
		</qa>
		<qa id="65" rating="2">			<question><![CDATA[q:  Which java.util classes and interfaces support event handling?]]></question>
			<answer><![CDATA[The EventObject class and the EventListener interface support event processing]]></answer>
		</qa>
		<qa id="66" rating="2">			<question><![CDATA[q:  Can an object's finalize() method be invoked while it is reachable?]]></question>
			<answer><![CDATA[An object's finalize() method cannot be invoked by the garbage collector while the object is still reachable. However, an object's finalize() method may be invoked by other objects.]]></answer>
		</qa>
		<qa id="67" rating="2">			<question><![CDATA[q:  What is the purpose of the Runtime class?]]></question>
			<answer><![CDATA[The purpose of the Runtime class is to provide access to the Java runtime system. 
It returns the runtime information like memory availability. <br/><br/>
<ul>
<li>Runtime.freeMemory() -> Returns JVM Free Memory </li>
<li>Runtime.maxMemory() -> Returns the maximum amount of memory that the JVM will attempt to use. It also helps to run the garbage collector </li>
<li>Runtime.gc() -> Invokes garbage collector</li>
</ul>]]></answer>
		</qa>
		<qa id="68" rating="2">			<question><![CDATA[q:  What is the purpose of the System class?]]></question>
			<answer><![CDATA[The purpose of the System class is to provide access to system resources.]]></answer>
		</qa>
		<qa id="69" rating="2">			<question><![CDATA[q:  Can an unreachable object become reachable again?]]></question>
			<answer><![CDATA[An unreachable object may become reachable again. This can happen when the object's finalize() method is invoked and the object performs an operation which causes it to become accessible to reachable object.]]></answer>
		</qa>
		<qa id="70" rating="2">			<question><![CDATA[q:  What is a bean? Where can it be used?]]></question>
			<answer><![CDATA[A Bean is a reusable and self-contained software component. Beans created using java take advantage of all the security and platform independent features of java. Bean can be plugged into any software application. Bean is a simple class which has set and get methods. It could be used within a JSP using JSP tags to use them.]]></answer>
		</qa>
		<qa id="71" rating="2">			<question><![CDATA[q:  What is the functionality of instanceOf() ?]]></question>
			<answer><![CDATA[instanceOf opertaor is used to check whether an object can be cast to a specific type without throwing ClassCastException.]]></answer>
		</qa>
		<qa id="72" rating="2">			<question><![CDATA[q: What would happen if you say this = null?]]></question>
			<answer><![CDATA[It will come up with Error Message 
"The left-hand side of an assignment must be a variable".]]></answer>
		</qa>
		<qa id="73" rating="2">			<question><![CDATA[q:  What is heap in Java?]]></question>
			<answer><![CDATA[It is a memory area which stores all the objects created by an executing program.]]></answer>
		</qa>
		<qa id="74" rating="2">			<question><![CDATA[q:  Why default constructor of base class will be called first in java?]]></question>
			<answer><![CDATA[A subclass inherits all the methods and fields (eligible one) from the base class, so base class is constructed in the process of creation of subclass object (subclass is also an object of superclass). Hence before initializing the default value of sub class the super class should be initialized using the default constructor.]]></answer>
		</qa>
		<qa id="75" rating="2">			<question><![CDATA[q:  What are the other ways to create an object other than creating as new object?]]></question>
			<answer><![CDATA[We can create object in different ways;<br/><br/> 
 <ul>
 <li>new operator </li>
 <li>class.forName: Classname obj = Class.forName("Fully Qualified class Name").newInstance(); </li>
 <li>newInstance </li>
 <li>object.clone </li>
</ul>]]></answer>
		</qa>
		<qa id="76" rating="2">			<question><![CDATA[q:  What is the difference between instance, object, reference and a class?]]></question>
			<answer><![CDATA[<ul>
<li>Class: A class is a user defined data type with set of data members & member functions </li>
<li>Object: An Object is an instance of a class </li>
<li>Reference: A reference is just like a pointer pointing to an object.</li>
<li>Instance: This represents the values of data members of a class at a particular time</li>
</ul>]]></answer>
		</qa>
		<qa id="77" rating="2">			<question><![CDATA[q:  Explain the user defined Exceptions?]]></question>
			<answer><![CDATA[User defined Exceptions are custom Exception classes defined by the user for specific purpose. A user defined exception can be created by simply sub-classing an Exception class or a subclass of an Exception class. This allows custom exceptions to be generated (using throw clause) and caught in the same way as normal exceptions. <br/><br/>
<pre>
 Eg: 
class Custom extends Exception { 
} 
</pre>]]></answer>
		</qa>
		<qa id="78" rating="2">			<question><![CDATA[q:  What classes of exceptions may be caught by a catch clause?]]></question>
			<answer><![CDATA[A catch clause can catch any exception that may be assigned to the Throwable type. This includes the Error and Exception types. Errors are generally irrecoverable conditions 
  Error's are irrecoverable exceptions. Usually a program terminates when an error is encountered.]]></answer>
		</qa>
		<qa id="79" rating="2">			<question><![CDATA[q: What is the difference between throw and throws keywords?]]></question>
			<answer><![CDATA[The <b>throw</b> keyword denotes a statement that causes an exception to be initiated. It takes the Exception object to be thrown as an argument. The exception will be caught by an enclosing try-catch block or propagated further up the calling hierarchy. <br/><br/>
The <b>throws</b> keyword is a modifier of a method that denotes that an exception may be thrown by the method. An exception can be rethrown.]]></answer>
		</qa>
		<qa id="80" rating="2">			<question><![CDATA[q: What class of exceptions are generated by the Java run-time system?]]></question>
			<answer><![CDATA[The Java runtime system generates Runtime Exceptions and Errors.]]></answer>
		</qa>
		<qa id="81" rating="2">			<question><![CDATA[q: What is the base class for Error and Exception?]]></question>
			<answer><![CDATA[Throwable]]></answer>
		</qa>
		<qa id="82" rating="2">			<question><![CDATA[q: What are Checked and Unchecked Exceptions?]]></question>
			<answer><![CDATA[<ul>
<li>A checked exception is a subclass of Exception, excluding class RuntimeException and its subclasses. Making an exception checked forces client programmers to deal with the exception may be thrown. Checked exceptions must be caught at compile time. Eg: IOException. </li>
<li>Unchecked exceptions are RuntimeException and any of its subclasses.  With an unchecked exception, however, the compiler doesn't force client programmers either to catch the exception or declare it in a throws clause.In fact, client programmers may not even know that the exception could be thrown. Eg: ArrayIndexOutOfBoundsException. </li>
<li>Class Error and its subclasses also are unchecked. Errors are often irrecoverable conditions.</li>
</ul>]]></answer>
		</qa>
		<qa id="83" rating="2">			<question><![CDATA[q: Does the code in finally block get executed if there is an exception and a return statement in a catch block?]]></question>
			<answer><![CDATA[The finally clause is used to provide the capability to execute code no matter whether or not an exception is thrown or caught. If an exception occurs and there is a return statement in catch block, the finally block is still executed. The finally block will not be executed when the System.exit(0) statement is executed earlier or on system shut down earlier or the memory is used up earlier before the thread goes to finally block. 
<br/><br/>
<pre>
try{ 
...
} 
catch{ 
... 
} 
finally{ 
//executed if exception occurs or not 
} 
</pre>]]></answer>
		</qa>
		<qa id="84" rating="2">			<question><![CDATA[q:  Does the order of placing catch statements matter in the catch block?]]></question>
			<answer><![CDATA[Yes, it does. The FileNoFoundException is inherited from the IOException. So FileNoFoundException is caught before IOException. Exception's subclasses have to be caught first before the General Exception]]></answer>
		</qa>
		<qa id="85" rating="2">			<question><![CDATA[q:  What is the difference between Abstract class and Interface. When should you use an abstract class, when an interface, when both?]]></question>
			<answer><![CDATA[<ul>
<li>Abstract class is a class which contain one or more abstract methods, which has to be implemented by sub classes. An abstract class can contain no abstract methods also i.e. abstract class may contain concrete methods. A Java Interface can contain only method declarations and public static final constants and doesn't contain their implementation. The classes which implement the Interface must provide the method definition for all the methods present. </li>
<li>Abstract classes are useful in a situation when some general methods should be implemented and specialization behavior should be implemented by subclasses. Interfaces are useful in a situation when all its properties need to be implemented by subclasses </li>
<li>All variables in an Interface are by default - public static final while an abstract class can have instance variables. </li>
<li>An interface is also used in situations when a class needs to extend an other class apart from the abstract class. In such situations its not possible to have multiple inheritance of classes. An interface on the other hand can be used when it is required to implement one or more interfaces. Abstract class does not support Multiple Inheritance whereas an Interface supports multiple Inheritance. </li>
<li>An Interface can only have public members whereas an abstract class can contain private as well as protected members. </li>
<li>A class implementing an interface must implement all of the methods defined in the interface, while a class extending an abstract class need not implement any of the methods defined in the abstract class. </li>
<li>The problem with an interface is, if you want to add a new feature (method) in its contract, then you MUST implement those method in all of the classes which implement that interface. However, in the case of an abstract class, the method can be simply implemented in the abstract class and the same can be called by its subclass </li>
<li>Interfaces are slow as it requires extra indirection to to find corresponding method in the actual class. Abstract classes are fast </li>
<li>Interfaces are often used to describe the peripheral abilities of a class, and not its central identity, E.g. an Automobile class might implement the Recyclable interface, which could apply to many otherwise totally unrelated objects. </li>
</ul> 
 Note: There is no difference between a fully abstract class (all methods declared as abstract and all fields are public static final) and an interface.<br/><br/> 
 Note: If the various objects are all of-a-kind, and share a common state and behavior, then tend towards a common base class. If all they 
 share is a set of method signatures, then tend towards an interface. <br/><br/>

 Similarities:  Neither Abstract classes nor Interface can be instantiated.]]></answer>
		</qa>
		<qa id="86" rating="2">			<question><![CDATA[q: What does it mean that a method or class is abstract?]]></question>
			<answer><![CDATA[<ul>
<li>An abstract class cannot be instantiated. Only its subclass implementations can be instantiated. A class that has one or more abstract methods must be declared abstract. A subclass that does not provide an implementation for its inherited abstract methods must also be declared abstract. You indicate that a class is abstract with the abstract keyword like this: </li>
<li>public abstract class AbstractClass </li>
<li>Abstract classes may contain abstract methods. A method declared abstract is not actually implemented in the class. It exists only to be overridden in subclasses.    </li>
<li>Abstract methods may only be included in abstract classes. However, an abstract class is not required to have any abstract methods, though most of them do. Each subclass of an abstract class must override the abstract methods of its superclasses or itself be declared abstract. Only the method's prototype is provided in the class definition. Also, a final method can not be abstract and vice versa. Methods specified in an interface are implicitly abstract.It has no body. </li>
</ul>]]></answer>
		</qa>
		<qa id="87" rating="1">			<question><![CDATA[q:  What must a class do to implement an interface?]]></question>
			<answer><![CDATA[The class must provide all of the methods in the interface and identify the interface in its implements clause.]]></answer>
		</qa>
		<qa id="88" rating="2">			<question><![CDATA[q:  What is an abstract method?]]></question>
			<answer><![CDATA[An abstract method is a method whose implementation is deferred to a subclass.]]></answer>
		</qa>
		<qa id="89" rating="2">			<question><![CDATA[q:  What is interface?What is a cloneable interface and how many methods does it contain?]]></question>
			<answer><![CDATA[An Interface is implicitly abstract and public. Interfaces provide support for multiple inheritance in Java. A class that implements the interfaces is bound to implement all the methods defined in Interface. <br/><br/>
Interfaces with empty bodies are called marker interfaces having certain property or behavior. Examples:java.lang.Cloneable,java.io.Serializable,java.util.EventListener. An interface body can contain constant declarations, method prototype declarations, nested class declarations, and nested interface declarations. 
  
 Example of Interface: 
 <pre>
public interface sampleInterface{ 
 public void functionOne(); 
 public long CONSTANT_ONE = 1000; 
}
 </pre>]]></answer>
		</qa>
		<qa id="90" rating="2">			<question><![CDATA[q:  What is an abstract class? Can you make an instance of an abstract class?]]></question>
			<answer><![CDATA[Abstract classes can contain abstract and concrete methods. Abstract classes cannot be instantiated directly i.e. we cannot call the constructor of an abstract class directly nor we can create an instance of an abstract class by using "Class.forName().newInstance()" (Here we get java.lang.InstantiationException). However, if we create an instance of a class that extends an Abstract class, compiler will initialize both the classes. Here compiler will implicitly call the constructor of the Abstract class.

 Abstract class is a template class that provides some general functionality but leaves specific implementation to its inheriting classes. 
Eg: 
<pre>
  
  abstract class AbstractClassExample{ 
  protected String name; 
 public String getname() { 
 return name; 
 } 
 public abstract void function(); 
 } </pre>
 Eg: Vehicle is an abstract class and Bus Truck, car etc are specific implementations]]></answer>
		</qa>
		<qa id="91" rating="2">			<question><![CDATA[q: How to define an Interface?]]></question>
			<answer><![CDATA[In Java Interface defines the methods but does not implement them. Interface can include constants. 
 A class that implements the interfaces is bound to implement all the methods defined in Interface. 
 eg:
 <pre> 
public interface SampleInterface { 
 public void functionOne(); 
 public long CONSTANT_ONE = 1000; 
}
 </pre>]]></answer>
		</qa>
		<qa id="92" rating="2">			<question><![CDATA[q: Can Abstract Class have constructors? Can interfaces have constructors?]]></question>
			<answer><![CDATA[Abstract class's can have a constructor, but you cannot access it through the object, since you cannot instantiate abstract class. To access the constructor create a sub class and extend the abstract class which is having the constructor. 
Eg:
<pre> 
 public abstract class AbstractExample { 
 public AbstractExample(){ 
 S.o.p("In AbstractExample()"); 
 } 
 } 
  public class Test extends AbstractExample{ 
 public static void main(String args[]){ 
 Test obj=new Test(); 
 } 
 } </pre>]]></answer>
		</qa>
		<qa id="93" rating="2">			<question><![CDATA[q: If interface & abstract class have same methods and those methods contain no implementation, which one would you prefer?]]></question>
			<answer><![CDATA[Obviously one should ideally go for an interface, as we can only extend one class. Implementing an interface for a class is very much effective rather than extending an abstract class because we can extend some other useful class for this subclass]]></answer>
		</qa>
		<qa id="94" rating="3">			<question><![CDATA[q:We encountered the dreaded java.lang.OutOfMemoryError PermGen space error.What does it mean ?]]></question>
			<answer><![CDATA[Permgen Space is the space where the class files are all loaded for the first time and there after they are loaded or referenced from there. This error means there is a lot of classes being loaded and not all are being unloaded. These class instances are cluttering the permgen space and resulting in this error.]]></answer>
		</qa>
		<qa id="95" rating="3">			<question><![CDATA[q: Explain Association,Aggregation, Composition ?]]></question>
			<answer><![CDATA[<b>Association (is a)</b>: In this relationship the object of one instance perform an action on behalf of the other class. The typical beahiour can be invoking the method of other class and using the member of the other class.
<pre>
public class MyMainClass{
 public void init(){
 new OtherClass.init();
 }
}
</pre>
<b>Aggregation (has a)</b> relationship between two classes. In this relationship the object of one class is a member of the other class. Aggregation always insists for a direction.
<pre>
public class MyMainClass{
 OtherClass otherClassObj = new OtherClass();
}
</pre>
<b>Composition </b>is a special type of aggregation relationship with a difference that its the compulsion for the OtherClass object (in previous example) to exist for the existence of MyMainClass.]]></answer>
		</qa>
		<qa id="96" rating="3">			<question><![CDATA[q:Explain HotSpot Java VM and its allocation?]]></question>
			<answer><![CDATA[For the HotSpot Java VM, the memory pools for serial garbage collection are the following.

<ul><li><b>Eden Space (heap)</b>: The pool from which memory is initially allocated for most objects.</li>
<li><b>Survivor Space (heap)</b>: The pool containing objects that have survived the garbage collection of the Eden space.</li>
<li><b>Tenured Generation (heap)</b>: The pool containing objects that have existed for some time in the survivor space.</li>
<li><b>Permanent Generation (non-heap)</b>: The pool containing all the reflective data of the virtual machine itself, such as class and method objects. With Java VMs that use class data sharing, this generation is divided into read-only and read-write areas.</li>
<li><b>Code Cache (non-heap)</b>: The HotSpot Java VM also includes a code cache, containing memory that is used for compilation and storage of native code.</li>
</ul>

<br/><br/>Java uses generational garbage collection. This means that if you have an object foo (which is an instance of some class), the more garbage collection events it survives (if there are still references to it), the further it gets promoted. It starts in the young generation (which itself is divided into multiple spaces - Eden and Survivor) and would eventually end up in the tenured generation if it survived long enough]]></answer>
		</qa>
		<qa id="97" rating="2">			<question><![CDATA[q: What is an immutable class?]]></question>
			<answer><![CDATA[Immutable class is a class which once created, it's contents can not be changed. Immutable objects are the objects whose state can not be changed once constructed. e.g. String class]]></answer>
		</qa>
		<qa id="98" rating="3">			<question><![CDATA[q: How to create an immutable class?]]></question>
			<answer><![CDATA[To create an immutable class following steps should be followed:
<ol>
<li>Create a final class.</li>
<li>Set the values of properties using constructor only.</li>
<li>Make the properties of the class final and private</li>
<li>Do not provide any setters for these properties.</li>
<li>If the instance fields include references to mutable objects, don't allow those objects to be changed:</li>
<li>Don't provide methods that modify the mutable objects.</li>
<li>Don't share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.</li>
</ol>

Eg:
<pre> 
public final class Immutable {
      private final String name; 
      public Immutable(final String name) { 
            super(); 
            this.name = name; 
      } 
      public String getName() { 
            return name; 
      } 
      
}</pre>]]></answer>
		</qa>
		<qa id="99" rating="2">			<question><![CDATA[q: Immutable objects are automatically thread-safe -true/false?]]></question>
			<answer><![CDATA[True. Since the state of the immutable objects can not be changed once they are created they are automatically synchronized/thread-safe.]]></answer>
		</qa>
		<qa id="100" rating="2">			<question><![CDATA[q: Which classes in java are immutable?]]></question>
			<answer><![CDATA[All wrapper classes in java.lang are immutable - 
String, Integer, Boolean, Character, Byte, Short, Long, Float, Double, BigDecimal, BigInteger]]></answer>
		</qa>
		<qa id="101" rating="2">			<question><![CDATA[q: What are the advantages of immutability?]]></question>
			<answer><![CDATA[<ul>
<li>Immutable objects are automatically thread-safe, the overhead caused due to use of synchronisation is avoided.</li>
<li>Once created the state of the immutable object can not be changed so there is no possibility of them getting into an inconsistent state.</li>
<li>The references to the immutable objects can be easily shared or cached without having to copy or clone them as there state can not be changed ever after construction.</li>
<li>The best use of the immutable objects is as the keys of a map.</li>
</ul>]]></answer>
		</qa>
	</category>
	<category name="Cloning">
		<qa id="102" rating="2">			<question><![CDATA[q: What are different types of cloning in Java?]]></question>
			<answer><![CDATA[Two type of cloning: - Deep and shallow cloning. By default shallow copy is used in Java. Object class has a method clone() which does shallow cloning.]]></answer>
		</qa>
		<qa id="103" rating="2">			<question><![CDATA[q: What is Shallow copy?]]></question>
			<answer><![CDATA[In shallow copy the object is copied without its contained objects.
Shallow clone only copies the top level structure of the object not the lower levels.
It is an exact bit copy of all the attributes.      
<pre>
	obj -->containedObj1
	   \-->containedObj2		    
</pre>
The shallow copy is done for obj and new object obj1 is created but contained objects of obj are not copied.
<pre>
	obj -->containedObj1 <--obj1
	   \-->containedObj2 <--
</pre>

It can be seen that no new objects are created for obj1 and it is referring to the same old contained objects. If either of the containedObj contain any other object no new reference is created]]></answer>
		</qa>
		<qa id="104" rating="3">			<question><![CDATA[q: What is deep copy and how it can be acheived?]]></question>
			<answer><![CDATA[In deep copy the object is copied along with the objects it refers to. Deep clone copies all the levels of the object from top to the bottom recursively.
<pre>
obj -->containedObj1
   \-->containedObj2	
</pre>	    
When a deep copy of the object is done new references are created.
<pre>
obj -->containedObj1    containedObj3<--obj2
   \-->containedObj2 	containedObj4<--/
</pre>	   
One solution is to simply implement your own custom method (e.g., deepCopy()) that returns a deep copy of an instance of one of your classes. This may be the best solution if you need a complex mixture of deep and shallow copies for different fields, but has a few significant drawbacks:
You must be able to modify the class (i.e., have the source code) or implement a subclass. If you have a third-party class for which you do not have the source and which is marked final, you are out of luck.<br/><br/>

You must be able to access all of the fields of the classes superclasses. If significant parts of the objectes state are contained in private fields of a superclass, you will not be able to access them.<br/>
You must have a way to make copies of instances of all of the other kinds of objects that the object references. This is particularly problematic if the exact classes of referenced objects cannot be known until runtime.<br/><br/>


Custom deep copy methods are tedious to implement, easy to get wrong, and difficult to maintain. The method must be revisited any time a change is made to the class or to any of its superclasses.<br/>
<br/>

Other common solution to the deep copy problem is to use Java Object Serialization (JOS). The idea is simple: Write the object to an array using JOSes ObjectOutputStream and then use ObjectInputStream to reconsistute a copy of the object. The result will be a completely distinct object, with completely distinct referenced objects. JOS takes care of all of the details: superclass fields, following object graphs, and handling repeated references to the same object within the graph.<br/><br/>

It will only work when the object being copied, as well as all of the other objects references directly or indirectly by the object, are serializable. (In other words, they must implement java.io.Serializable.) Fortunately it is often sufficient to simply declare that a given class implements java.io.Serializable and let Javaes default serialization mechanisms do their thing. Java Object Serialization is slow, and using it to make a deep copy requires both serializing and deserializing.<br/>
There are ways to speed it up (e.g., by pre-computing serial version ids and defining custom readObject() and writeObject() methods), but this will usually be the primary bottleneck. The byte array stream implementations included in the java.io package are designed to be general enough to perform reasonable well for data of different sizes and to be safe to use in a multi-threaded environment. These characteristics, however, slow down ByteArrayOutputStream and (to a lesser extent) ByteArrayInputStream .
</pre>]]></answer>
		</qa>
		<qa id="105" rating="2">			<question><![CDATA[q: What is difference between deep and shallow cloning?]]></question>
			<answer><![CDATA[The differences are as follows:
Consider the class:
<pre>
	public class MyData{
		String id;
		Map myData;
	}
</pre>
The shallow copying of this object will have new id object and values as  but will point to the myData of the original object. So a change in myData by either original or cloned object will be reflected in other also. But in deep copying there will be new id object and also new myData object and independent of original object but with same values.<br/><br/>

Shallow copying is default cloning in Java which can be achieved using clone() method of Object class. For deep copying some extra logic need to be provided.]]></answer>
		</qa>
		<qa id="106" rating="2">			<question><![CDATA[q: What are the disadvantages of deep cloning?]]></question>
			<answer><![CDATA[Disadvantages of using Serialization to achieve deep cloning are:
<ul>
<li>Serialization is more expensive than using object.clone().</li>
<li>Not all objects are serializable.</li>
<li>Serialization is not simple to implement for deep cloned object..</li>
</ul>]]></answer>
		</qa>
	</category>
	<category name="Collections">
		<qa id="107" rating="1">			<question><![CDATA[q:What is the Collections API?]]></question>
			<answer><![CDATA[The Collections API is a set of classes and interfaces that support operations on collections of objects.]]></answer>
		</qa>
		<qa id="108" rating="1">			<question><![CDATA[q:What is the List,Vector,Iterator,Map,Set interface?]]></question>
			<answer><![CDATA[<ul>
<li>List interface provides support for ordered collections of objects. 	</li>
<li>Vector class provides capability to implement a growable array of objects. 	</li>
<li>Iterator interface is used to step through elements of a Collection . 	</li>
<li>Map interface replaces JDK 1.1 Dictionary class and is used associate keys with values.</li>
<li>Set interface provides methods for accessing elements of a finite mathematical set. Sets do not allow duplicate elements</li>
</ul>]]></answer>
		</qa>
		<qa id="109" rating="2">			<question><![CDATA[q:What is the typical use of Hashtable?]]></question>
			<answer><![CDATA[Whenever a program wants to store a key value pair, one can use Hashtable.]]></answer>
		</qa>
		<qa id="110" rating="2">			<question><![CDATA[q:I am trying to store an object using a key in a Hashtable. And some other object already exists in that location, then what will happen?]]></question>
			<answer><![CDATA[The existing object will be overwritten and thus it will be lost.]]></answer>
		</qa>
		<qa id="111" rating="2">			<question><![CDATA[q:What is the difference between the size and capacity of a Vector?]]></question>
			<answer><![CDATA[The size is the number of elements actually stored in the vector, while capacity is the maximum number of elements it can store at a given instance of time.]]></answer>
		</qa>
		<qa id="112" rating="2">			<question><![CDATA[q:What is difference between ArrayList and vector?]]></question>
			<answer><![CDATA[<ol>
<li> Synchronization - ArrayList is not thread-safe whereas Vector is thread-safe. In Vector class each method like add(), get(int i) is surrounded with a synchronized block and thus making Vector class thread-safe.</li>

<li>Data growth - Internally, both the ArrayList and Vector hold onto their contents using an Array. When an element is inserted into an ArrayList or a Vector, the object will need to expand its internal array if it runs out of room. A Vector defaults to doubling the size of its array, while the ArrayList increases its array size by 50 percent.</li>
</ol>]]></answer>
		</qa>
		<qa id="113" rating="2">			<question><![CDATA[q:What is difference between HashMap and HashTable?]]></question>
			<answer><![CDATA[Both collections implements Map. Both collections store value as key-value pairs. The key differences between the two are
<ol>
<li>Hashmap is not synchronized in nature but hshtable is.</li>
<li>Another difference is that iterator in the HashMap is fail-safe while the enumerator for the Hashtable isn't.
Fail-safe - if the Hashtable is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException</li>
<li>HashMap permits null values and only one null key, while Hashtable doesn't allow key or value as null.</li>
</ol>]]></answer>
		</qa>
		<qa id="114" rating="2">			<question><![CDATA[q:When to use ArrayList or LinkedList ?]]></question>
			<answer><![CDATA[<ol>
<li>For the ArrayList, doing  random lookup using "get" is fast, but for LinkedList, it's slow. It's slow because there's no efficient way to index into the middle of a linked list.</li>
<li>When removing elements, using ArrayList is slow. This is because all remaining elements in the underlying array of Object instances must be shifted down for each remove operation. But here LinkedList is fast, because deletion can be done simply by changing a couple of links.</li>
<li>So an ArrayList works best for cases where you're doing random access on the list, and a LinkedList works better if you're doing a lot of editing in the middle of the list.</li>
</ol>]]></answer>
		</qa>
		<qa id="115" rating="3">			<question><![CDATA[q: Which design pattern Iterator follows?]]></question>
			<answer><![CDATA[It follows Iterator design pattern which is a type of behavioral pattern. I allows you to navigate through a collection of data using a common interface without knowing about the underlying implementation. The benefits of Iterator are about their strength to provide a common interface for iterating through collections without bothering about underlying implementation.<br/>

Example - The class java.util.Enumeration : It represents and abstract means of iterating over a collection of elements in some sequential order without the client having to know the representation of the collection being iterated over. It can be used to provide a uniform interface for traversing collections of all kinds.
</pre>]]></answer>
		</qa>
		<qa id="116" rating="1">			<question><![CDATA[q:Can a vector or ArrayList contain heterogenous objects?]]></question>
			<answer><![CDATA[Yes a Vector can contain heterogenous objects. Because a Vector stores everything in terms of Object.]]></answer>
		</qa>
		<qa id="117" rating="2">			<question><![CDATA[q:What is an enumeration?]]></question>
			<answer><![CDATA[It is a construct which collection classes return when you request a collection of all the objects stored in the collection. It allows sequential access to all the elements stored in the collection.]]></answer>
		</qa>
		<qa id="118" rating="2">			<question><![CDATA[q:Considering the basic properties of Vector and ArrayList, where will you use Vector and where will you use ArrayList?]]></question>
			<answer><![CDATA[Vector is synchronized while ArrayList is not. Thus whenever there is a possibility of multiple threads accessing the same instance, one should use Vector. While if not multiple threads are going to access the same instance then use ArrayList. Non synchronized data structure will give better performance than the synchronized one.]]></answer>
		</qa>
		<qa id="119" rating="2">			<question><![CDATA[q:  What is HashMap and Map?]]></question>
			<answer><![CDATA[Map is Interface and Hashmap is class that implements this interface.]]></answer>
		</qa>
		<qa id="120" rating="2">			<question><![CDATA[q: What is the difference b/w Iterator and ListIterator?]]></question>
			<answer><![CDATA[Iterator enables you to cycle through a collection in the forward direction only, for obtaining or removing elements<br/> 
 ListIterator extends Iterator, allow bidirectional traversal of list and the modification of elements]]></answer>
		</qa>
		<qa id="121" rating="2">			<question><![CDATA[q: Difference between HashMap and HashTable? Can we make hashmap synchronized?]]></question>
			<answer><![CDATA[HashMap is not synchronized while HashTable is. <br/> 
 
  HashMap can be synchronized by <br/>
  Map m = Collections.synchronizeMap(hashMap);]]></answer>
		</qa>
		<qa id="122" rating="2">			<question><![CDATA[q:  What is the difference between set and list?]]></question>
			<answer><![CDATA[A Set stores elements in an unordered way and does not contain duplicate elements, whereas a list stores elements in an ordered way but may contain duplicate elements.]]></answer>
		</qa>
		<qa id="123" rating="2">			<question><![CDATA[q:  What is an Iterator interface? Is Iterator a Class or Interface? What is its use?]]></question>
			<answer><![CDATA[The Iterator is an interface, used to traverse through the elements of a Collection. It is not advisable to modify the collection itself while traversing an Iterator.]]></answer>
		</qa>
		<qa id="124" rating="2">			<question><![CDATA[q:  How can we access elements of a collection?]]></question>
			<answer><![CDATA[We can access the elements of a collection using the following ways: 
 <ol>
 <li>Every collection object has get(index) method to get the element of the object. This method will return Object.</li> 
 <li>Collection provide Enumeration or Iterator object so that we can get the objects of a collection one by one. </li>
 </ol>]]></answer>
		</qa>
		<qa id="125" rating="2">			<question><![CDATA[q:  What's the difference between a queue and a stack?]]></question>
			<answer><![CDATA[Stack is a data structure that is based on last-in-first-out rule (LIFO), while queues are based on First-in-first-out (FIFO) rule.]]></answer>
		</qa>
		<qa id="126" rating="2">			<question><![CDATA[q:  What is the Properties class?]]></question>
			<answer><![CDATA[The properties class is a subclass of Hashtable that can be read from or written to a stream. It also provides the capability to specify a set of default values to be used.]]></answer>
		</qa>
		<qa id="127" rating="2">			<question><![CDATA[q: Which implementation of the List interface provides for the fastest insertion of a new element into the middle of the list?]]></question>
			<answer><![CDATA[ArrayList and Vector both use an array to store the elements of the list. When an element is inserted into the middle of the list the elements that follow the insertion point must be shifted to make room for the new element.<br/>
The LinkedList is implemented using a doubly linked list; an insertion requires only the updating of the links at the point of insertion. <br/>
Therefore, the LinkedList allows for fast insertions and deletions.]]></answer>
		</qa>
		<qa id="128" rating="2">			<question><![CDATA[q: How can we use hashset in collection interface?]]></question>
			<answer><![CDATA[This class implements the set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the Null element. 
This class offers constant time performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets.]]></answer>
		</qa>
		<qa id="129" rating="2">			<question><![CDATA[q:  What are differences between Enumeration, ArrayList, Hashtable and Collections and Collection?]]></question>
			<answer><![CDATA[<ul>
<li>Enumeration: It is series of elements. It can be use to enumerate through the elements of a vector, keys or values of a hashtable. You can not remove elements from Enumeration. </li>
<li>ArrayList: It is re-sizable array implementation. Belongs to 'List' group in collection. It permits all elements, including null. It is not thread -safe. </li>
<li>Hashtable: It maps key to value. You can use non-null value for key or value. It is part of group Map in collection. </li>
<li>Collections: It implements Polymorphic algorithms which operate on collections. </li>
<li>Collection: It is the root interface in the collection hierarchy. </li>
</ul>]]></answer>
		</qa>
		<qa id="130" rating="2">			<question><![CDATA[q:  What is difference between array and arraylist?]]></question>
			<answer><![CDATA[<ul>
<li>An ArrayList is resizable, where as, an array is not. ArrayList is a part of the Collection Framework. We can store any type of objects, and we can deal with only objects. It is growable. Array is collection of similar data items. We can have array of primitives or objects. It is of fixed size. We can have multi dimensional arrays. </li>
<li>Array: can store primitive ArrayList: Stores object only </li>
<li>Array: fix size ArrayList: resizable </li>
<li>Array: can have multi dimensional </li>
<li>Array: lang ArrayList: Collection framework </li>
</ul>]]></answer>
		</qa>
		<qa id="131" rating="2">			<question><![CDATA[q:  Can you limit the initial capacity of vector in java?]]></question>
			<answer><![CDATA[Yes you can limit the initial capacity. We can construct an empty vector with specified initial capacity <br/>
  public vector(int initialcapacity)]]></answer>
		</qa>
		<qa id="132" rating="2">			<question><![CDATA[q: What method should the key class of Hashmap override?]]></question>
			<answer><![CDATA[The methods to override are equals() and hashCode().]]></answer>
		</qa>
		<qa id="133" rating="2">			<question><![CDATA[q: What is the difference between Enumeration and Iterator?]]></question>
			<answer><![CDATA[The functionality of Enumeration interface is duplicated by the Iterator interface. Iterator has a remove() method while Enumeration doesn't. Enumeration acts as Read-only interface, because it has the methods only to traverse and fetch the objects, where as using Iterator we can manipulate the objects also like adding and removing the objects. 
So Enumeration is used when ever we want to make Collection objects as Read-only.]]></answer>
		</qa>
		<qa id="134" rating="2">			<question><![CDATA[q:You need to insert huge amount of objects and randomly delete them one by one. Which Collection data structure is best bet?]]></question>
			<answer><![CDATA[LinkedList]]></answer>
		</qa>
		<qa id="135" rating="3">			<question><![CDATA[q: What goes wrong if the HashMap key has same hashCode value?]]></question>
			<answer><![CDATA[It leads to 'Collision' wherein all the values are stored in same bucket. Hence, the searching time increases quad radically.]]></answer>
		</qa>
		<qa id="136" rating="3">			<question><![CDATA[q: If hashCode() method is overridden but equals() is not, for the class 'A', then what may go wrong if you use this class as a key in HashMap?]]></question>
			<answer><![CDATA[In Java, every object has access to the equals() method because it is inherited from the Object class. However, this default implementation just simply compares the memory addresses of the objects. You can override the default implementation of the equals() method defined in java.lang.Object. If you override the equals(), you MUST also override hashCode(). Otherwise a violation of the general contract for Object.hashCode will occur, which can have unexpected repercussions when your class is in conjunction with all hash-based collections.<br/><br/>

Here is the contract, copied from the java.lang.Object specialization:<br/>

The general contract of hashCode is:<br/>

<ul><li>Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</li>
<li>
If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.</li>
<li>
It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables.</li>
</ul>
<br/>
As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the JavaTM programming language.)<br/><br/>

The default implementation of equals() method checks to see if the two objects have the same identity. Similarly, the default implementation of the hashCode() method returns an integer based on the object's identity and is not based on the values of instance (and class) variables of the object. No matter how many times the values of its instance variables (data fields) change, the hash code calculated by the default hashCode implementation does not change during the life of the object.<br/><br/>

Consider the following code, we have overridden equals() method to check if two objects are equal based on the values of their instance variables. Two objects may be stored at different memory addresses but may still be equal base on their instance variable.
<pre>
public class CustomerID {
  private long crmID;
  private int nameSpace;

  public CustomerID(long crmID, int nameSpace) {
    super();
    this.crmID = crmID;
    this.nameSpace = nameSpace;
  }

  public boolean equals(Object obj) {
    //null instanceof Object will return false
    if (!(obj instanceof CustomerID))
      return false;
    if (obj == this)
      return true;
    return this.crmID == ((CustomerID) obj).crmID &&
      this.nameSpace == ((CustomerID) obj).nameSpace;
  }

  public static void main(String[] args) {
    Map m = new HashMap();
    m.put(new CustomerID(2345891234L,0),"hello");
    S.o.p(m.get(new CustomerID(2345891234L,0)));
  }

}
Compile and run the above code, the output result is

null
</pre><br/>

What is wrong? The two instances of CustomerID are logically equal according to the class's equals method. Because the hashCode() method is not overridden, these two instances' identities are not in common to the default hashCode implementation. Therefore, the Object.hashCode returns two seemingly random numbers instead of two equal numbers. Such behavior violates "Equal objects must have equal hash codes" rule defined in the hashCode contract.<br/><br/>

Let's provide a simple hashCode() method to fix this problem:<br/>
<pre>
public class CustomerID {
  private long crmID;
  private int nameSpace;

  public CustomerID(long crmID, int nameSpace) {
    super();
    this.crmID = crmID;
    this.nameSpace = nameSpace;
  }

  public boolean equals(Object obj) {
    //null instanceof Object will always return false
    if (!(obj instanceof CustomerID))
      return false;
    if (obj == this)
      return true;
    return  this.crmID == ((CustomerID) obj).crmID &&
            this.nameSpace == ((CustomerID) obj).nameSpace;
  }

  public int hashCode() {
    int result = 0;
    result = (int)(crmID/12) + nameSpace;
    return result;
  }

  public static void main(String[] args) {
    Map m = new HashMap();
    m.put(new CustomerID(2345891234L,0),"Hello");
    S.o.p(m.get(new CustomerID(2345891234L,0)));
  }

}
Compile and run the above code, the output result is

Hello
</pre>
The hashcode distribution for instances of a class should be random. This is exactly what is meant by the third provision of the hashCode contract. Write a correct hashCode method is easy, but to write an effective hashCode method is extremely difficult.<br/><br/>

For example, From How to Avoid Traps and Correctly Override Methods From java.lang.Object: If you are unsure how to implement hashCode(), just always return 0 in your implementations. So all of your custom objects will return the same hash code. Yes, it turns hashtable of your objects into one (possibly) long linked-list, but you have implemented hashCode() correctly! <br/><br/>

<pre>
public int hashCode(){
  return 0;
}
</pre>
It's legal because it ensures that equal objects have the same hash code, but it also indicates that every object has the same hash code. So every object will be hashed into the same bucket, and hash tables degenerate to linked lists. The performance is getting worse when it needs to process a large number of objects. How to implement a good hash function is a big topic and we will not cover here.]]></answer>
		</qa>
		<qa id="137" rating="3">			<question><![CDATA[q: How will you remove duplicate element from a List?]]></question>
			<answer><![CDATA[Add the List elements to Set. Duplicates will be removed.]]></answer>
		</qa>
		<qa id="138" rating="2">			<question><![CDATA[q:Which java.util classes and interfaces support event handling?]]></question>
			<answer><![CDATA[The EventObject class and the EventListener interface support event processing.]]></answer>
		</qa>
	</category>
	<category name="Exception">
		<qa id="139" rating="2">			<question><![CDATA[q:What is an Exception?]]></question>
			<answer><![CDATA[The exception is said to be thrown whenever an exceptional event occurs in java which signals that something is not correct with the code written and may give unexpected result. An exceptional event is a occurrence of condition which alters the normal program flow. Exceptional handler is the code that does something about the exception.]]></answer>
		</qa>
		<qa id="140" rating="2">			<question><![CDATA[q:Exceptions are defined in which java package?]]></question>
			<answer><![CDATA[All the exceptions are subclasses of java.lang.Exception]]></answer>
		</qa>
		<qa id="141" rating="2">			<question><![CDATA[q:How are the exceptions handled in java?]]></question>
			<answer><![CDATA[When an exception occurs the execution of the program is transferred to an appropriate exception handler.The try-catch-finally block is used to handle the exception.<br/>
The code in which the exception may occur is enclosed in a try block, also called as a guarded region.<br/>
The catch clause matches a specific exception to a block of code which handles that exception.
And the clean up code which needs to be executed no matter the exception occurs or not is put inside the finally block]]></answer>
		</qa>
		<qa id="142" rating="2">			<question><![CDATA[q:Explain the exception hierarchy in java.]]></question>
			<answer><![CDATA[Throwable is a parent class off all Exception classes. <br/>
They are two types of Exceptions: Checked exceptions and UncheckedExceptions. Both type of exceptions extends Exception class.]]></answer>
		</qa>
		<qa id="143" rating="2">			<question><![CDATA[q:What is Runtime Exception or unchecked exception?]]></question>
			<answer><![CDATA[Runtime exceptions represent problems that are the result of a programming problem. Such problems include arithmetic exceptions, such as dividing by zero; pointer exceptions, such as trying to access an object through a null reference; and indexing exceptions. Runtime exceptions need not be explicitly caught in try catch block as it can occur anywhere in a program, and in a typical one they can be very numerous. Having to add runtime exceptions in every method declaration would reduce a program's clarity. Thus, the compiler does not require that you catch or specify runtime exceptions (although you can). The solution to rectify is to correct the programming logic where the exception has occurred or provide a check.]]></answer>
		</qa>
		<qa id="144" rating="2">			<question><![CDATA[q:What is checked exception?]]></question>
			<answer><![CDATA[Checked exception are the exceptions which forces the programmer to catch them explicitly in try-catch block. It is a subClass of Exception. Eg: IOException.]]></answer>
		</qa>
		<qa id="145" rating="2">			<question><![CDATA[q:What is difference between Error and Exception?]]></question>
			<answer><![CDATA[An error is an irrecoverable condition occurring at runtime. Such as OutOfMemory error. These JVM errors and you can not repair them at runtime.Though error can be caught in catch block but the execution of application will come to a halt and is not recoverable.
While exceptions are conditions that occur because of bad input etc.<br/><br/>
e.g. FileNotFoundException will be thrown if the specified file does not exist. Or a NullPointerException will take place if you try using a null reference. In most of the cases it is possible to recover from an exception (probably by giving user a feedback for entering proper values etc.)]]></answer>
		</qa>
		<qa id="146" rating="2">			<question><![CDATA[q:What is difference between ClassNotFoundException and NoClassDefFoundError?]]></question>
			<answer><![CDATA[A ClassNotFoundException is thrown when the reported class is not found by the ClassLoader in the CLASSPATH. It could also mean that the class in question is trying to be loaded from another class which was loaded in a parent classloader and hence the class from the child classloader is not visible.<br/><br/>

Consider if NoClassDefFoundError occurs which is something like<br/>
java.lang.NoClassDefFoundError<br/>
src/com/TestClass<br/>
does not mean that the TestClass class is not in the CLASSPATH. It means that the class TestClass was found by the ClassLoader however when trying to load the class, it ran into an error reading the class definition. This typically happens when the class in question has static blocks or members which use a Class that's not found by the ClassLoader. So to find the culprit, view the source of the class in question (TestClass in this case) and look for code using static blocks or static members.]]></answer>
		</qa>
		<qa id="147" rating="2">			<question><![CDATA[q:What is throw keyword?]]></question>
			<answer><![CDATA[Throw keyword is used to throw the exception manually. It is mainly used when the program fails to satisfy the given condition and it wants to warn the application.The exception thrown should be subclass of Throwable.
 <pre>
public void parent(){
   try{
      child();
     }catch(MyCustomException e){
     }
}

public void child{
	String iAmMandatory=null;
	if(iAmMandatory == null){
	throw (new MyCustomException("Eek!");
   }
}	
 </pre>]]></answer>
		</qa>
		<qa id="148" rating="2">			<question><![CDATA[q:What is use of throws keyword?]]></question>
			<answer><![CDATA[If the function is not capable of handling the exception then it can ask the calling method to handle it by simply putting the throws clause at the function declaration.
 <pre>
 
  public void child <b>throws</b> MyCustomException{
  	 ....
   }
 </pre>]]></answer>
		</qa>
		<qa id="149" rating="2">			<question><![CDATA[q:What are the possible combination to write try, catch finally block?]]></question>
			<answer><![CDATA[<pre>
1. try{
//lines of code that may throw an exception
}catch(Exception e){
//lines of code to handle the exception thrown in try block
}finally{
//the clean code which is executed always no matter the exception occurs or not.
}

2. try{
}finally{}

3. try{
}catch(Exception e){
//lines of code to handle the exception thrown in try block
}
</pre>

The catch blocks must always follow the try block.
If there are more than one catch blocks they all must follow each other without any block in between. 
The finally block must follow the catch block if one is present or if the catch block is absent the finally block must follow the try block.]]></answer>
		</qa>
		<qa id="150" rating="2">			<question><![CDATA[q:How to create custom Exception?]]></question>
			<answer><![CDATA[To create you own exception extend the Exception class or any of its subclasses.
e.g.
<ol>
<li> class New1Exception extends Exception { } // this will create Checked Exception</li>
<li>class NewException extends IOExcpetion { } // this will create Checked exception</li>
<li> class NewException extends NullPonterExcpetion { } // this will create UnChecked exception</li>
</ol>]]></answer>
		</qa>
		<qa id="151" rating="2">			<question><![CDATA[q:When to make a custom checked Exception or custom unchecked Exception?]]></question>
			<answer><![CDATA[If an application can reasonably be expected to recover from an exception, make it a checked exception. If an application cannot do anything to recover from the exception, make it an unchecked exception.]]></answer>
		</qa>
		<qa id="152" rating="2">			<question><![CDATA[q:)What is StackOverflowError?]]></question>
			<answer><![CDATA[The StackOverFlowError is an Error Object thorwn by the Runtime System when it Encounters that your application/code has ran out of the memory. It may occur in case of recursive methods or a large amount of data is fetched from the server and stored in some object. This error is generated by JVM.
<pre>

e.g. void swap(){
swap();
}
</pre>]]></answer>
		</qa>
		<qa id="153" rating="2">			<question><![CDATA[q:Why did the designers decide to force a method to specify all uncaught checked exceptions that can be thrown within its scope?]]></question>
			<answer><![CDATA[Any Exception that can be thrown by a method is part of the method's public programming interface. Those who call a method must know about the exceptions that a method can throw so that they can decide what to do about them. These exceptions are as much a part of that method's programming interface as its parameters and return value.]]></answer>
		</qa>
		<qa id="154" rating="2">			<question><![CDATA[q:Once the control switches to the catch block does it return back to the try block to execute the balance code?]]></question>
			<answer><![CDATA[No. Once the control jumps to the catch block it never returns to the try block but it goes to finally block(if present).]]></answer>
		</qa>
		<qa id="155" rating="2">			<question><![CDATA[q:Where is the clean up code like release of resources is put in try-catch-finally block and why?]]></question>
			<answer><![CDATA[The code is put in a finally block because irrespective of try or catch block execution the control will flow to finally block. Typically finally block contains release of connections, closing of result set etc.]]></answer>
		</qa>
		<qa id="156" rating="2">			<question><![CDATA[q:What happens if the exception is never caught and throws down the method stack?]]></question>
			<answer><![CDATA[If the exception is not caught by any of the method in the method's stack till you get to the main() method, the main method throws that exception and the JVM halts its execution.]]></answer>
		</qa>
		<qa id="157" rating="2">			<question><![CDATA[q:How do you get the descriptive information about the Exception occurred during the program execution?]]></question>
			<answer><![CDATA[All the exceptions inherit a method printStackTrace() from the Throwable class. This method prints the stack trace from where the exception occurred. It prints the most recently entered method first and continues down, printing the name of each method as it works its way down the call stack from the top.]]></answer>
		</qa>
		<qa id="158" rating="2">			<question><![CDATA[q:Can you catch more than one exceptions in a single catch block?]]></question>
			<answer><![CDATA[Yes. If the exception class specified in the catch clause has subclasses, any exception object that is a subclass of the specified Exception class will be caught by that single catch block.
E.g..
<pre>

try {
// Some code here that can throw an IOException
}
catch (IOException e) {
e.printStackTrace();
}

</pre>
The catch block above will catch IOException and all its subclasses e.g. FileNotFoundException etc.]]></answer>
		</qa>
		<qa id="159" rating="2">			<question><![CDATA[q:)Why is not considered as a good practice to write a single catchall handler to catch all the exceptions?]]></question>
			<answer><![CDATA[If you use the Superclass Exception in the catch block then you will not get the valuable information about each of the exception thrown during the execution, though you can find out the class of the exception occurred. Also it will reduce the readability of the code as the programmer will not understand what is the exact reason for putting the try-catch block.]]></answer>
		</qa>
		<qa id="160" rating="2">			<question><![CDATA[q:What is exception matching?]]></question>
			<answer><![CDATA[Exception matching is the process by which the the jvm finds out the matching catch block for the exception thrown from the list of catch blocks. When an exception is thrown, Java will try to find by looking at the available catch clauses in the top down manner. If it doesn't find one, it will search for a handler for a supertype of the exception. If it does not find a catch clause that matches a supertype for the exception, then the exception is propagated down the call stack. This process is called exception matching.]]></answer>
		</qa>
		<qa id="161" rating="2">			<question><![CDATA[q:What happens if the handlers for the most specific exceptions is placed above the more general exceptions handler?]]></question>
			<answer><![CDATA[Compilation fails. The catch block for handling the most specific exceptions must always be placed above the catch block written to handle the more general exceptions.]]></answer>
		</qa>
		<qa id="162" rating="2">			<question><![CDATA[q:Does the order of the catch blocks matter if the Exceptions caught by them are not subtype or supertype of each other?]]></question>
			<answer><![CDATA[No. If the exceptions are siblings in the Exception class's hierarchy i.e. If one Exception class is not a subtype or supertype of the other, then the order in which their handlers(catch clauses) are placed does not matter.]]></answer>
		</qa>
		<qa id="163" rating="2">			<question><![CDATA[q:What happens if a method does not throw an checked Exception directly but calls a method that does? What does 'Ducking' the exception mean?]]></question>
			<answer><![CDATA[If a method does not throw an checked Exception directly but calls a method that throws an exception then the calling method must handle the throw exception or declare the exception in its throws clause. If the calling method does not handle and declares the exception, the exceptions is passed to the next method in the method stack. This is called as ducking the exception down the method stack.<br/><br/>

e.g. The code below will not compile as the getCar() method has not declared the CarNotFoundException which is thrown by the getColor () method.
<pre>
void getCar() {
getColor();
}
void getColor () {
throw new CarNotFoundException();
}
Fix for the above code is
void getCar() throws CarNotFoundException {
getColor();
}
void getColor () {
throw new CarNotFoundException();
}</pre>]]></answer>
		</qa>
		<qa id="164" rating="2">			<question><![CDATA[q:Is an empty catch block legal?]]></question>
			<answer><![CDATA[Yes. But its not a good practice as it makes it difficult to troubleshoot.]]></answer>
		</qa>
		<qa id="165" rating="2">			<question><![CDATA[q:Can a catch block throw the exception caught by itself?]]></question>
			<answer><![CDATA[Yes. This is called rethrowing of the exception by catch block.
e.g. the catch block below catches the FileNotFound exception and rethrows it again.
<pre>
void chkEx() throws FileNotFoundException {
try{
....
}catch(FileNotFound eFnf){
throw FileNotFound();
}
}</pre>]]></answer>
		</qa>
	</category>
	<category name="Garbage collection">
		<qa id="166" rating="2">			<question><![CDATA[q:  Explain garbage collection and how can you force the garbage collection?]]></question>
			<answer><![CDATA[The purpose of garbage collection is to identify and discard objects that are no longer needed by a program so that their resources can be reclaimed and reused. A Java object is subject to garbage collection when it becomes unreachable to the program in which it is used. Garbage collection is also called automatic memory management as JVM automatically removes the unused objects  from the memory. <br/>
Every class inherits finalize() method from java.lang.Object, the finalize() method is called by garbage collector when it determines no more references to the object exists. On calling System.gc() and Runtime.gc(), JVM tries to recycle the unused objects, but there is no guarantee when all the objects will be garbage collected. There is no guarantee that Garbage collection will start immediately upon request of System.gc().]]></answer>
		</qa>
		<qa id="167" rating="2">			<question><![CDATA[q:  It is a daemon thread. Can an object's finalize() method be invoked while it is reachable?]]></question>
			<answer><![CDATA[An object's finalize() method cannot be invoked by the garbage collector while the object is still reachable. However, an object's finalize() method may be invoked by other objects.]]></answer>
		</qa>
		<qa id="168" rating="2">			<question><![CDATA[q: Does garbage collection guarantee that a program will not run out of memory?]]></question>
			<answer><![CDATA[Garbage collection does not guarantee that a program will not run out of memory. It is possible for programs to use up memory resources faster than they are garbage collected. It is also possible for programs to create objects that are not subject to garbage collection.]]></answer>
		</qa>
		<qa id="169" rating="2">			<question><![CDATA[q: What is the purpose of finalization?]]></question>
			<answer><![CDATA[The purpose of finalization is to give an unreachable object the opportunity to perform any cleanup, before the object gets garbage collected. For example, closing an opened database Connection.]]></answer>
		</qa>
		<qa id="170" rating="2">			<question><![CDATA[q: If an object is garbage collected, can it become reachable again?]]></question>
			<answer><![CDATA[Once an object is garbage collected, It can no longer become reachable again.]]></answer>
		</qa>
		<qa id="171" rating="2">			<question><![CDATA[q:Which part of the memory is involved in Garbage Collection? Stack or Heap?]]></question>
			<answer><![CDATA[Heap]]></answer>
		</qa>
		<qa id="172" rating="2">			<question><![CDATA[q:Is garbage collector a dameon thread?]]></question>
			<answer><![CDATA[Yes. A dameon thread runs behind the application. It is started by JVM.]]></answer>
		</qa>
		<qa id="173" rating="3">			<question><![CDATA[q:Garbage Collector is controlled by whom?]]></question>
			<answer><![CDATA[The JVM controls the Garbage Collector; it decides when to run the Garbage Collector. JVM runs the Garbage Collector when it realizes that the memory is running low, but this behavior of jvm can not be guaranteed.
One can request the Garbage Collection to happen from within the java program but there is no guarantee that this request will be taken care of by jvm.]]></answer>
		</qa>
		<qa id="174" rating="2">			<question><![CDATA[q:When does an object become eligible for garbage collection?]]></question>
			<answer><![CDATA[An object becomes eligible for Garbage Collection when no live thread can access it.]]></answer>
		</qa>
		<qa id="175" rating="3">			<question><![CDATA[q:What are the different ways to make an object eligible for Garbage Collection when it is no longer needed?]]></question>
			<answer><![CDATA[1. Set all available object references to null once the purpose of creating the object is served.
<br/><br/>

2. Make the reference variable to refer to another object : Decouple the reference variable from the object and set it refer to another object, so the object which it was referring to before reassigning is eligible for Garbage Collection.

<pre>
publc class GarbageCollnTest2 {

   public static void main(String [] args){
	String str1 = "Garbage collected after use";
	String str2 = "Another String";
	S.o.p(str1);
	//String object referred by str1 is 
 	  //not eligible for GC yet

	str1 = str2;


   }

}
</pre>
 Now the str1 variable referes to the String object "Another String" and the object "Garbage collected after use" is not referred by any variable and hence is eligible for GC 
<br/><br/>

3) Creating Islands of Isolation : If you have two instance reference variables which are referring to the instances of the same class, and these two reference variables refer to each other and the objects referred by these reference variables do not have any other valid reference then these two objects are said to form an Island of Isolation and are eligible for Garbage Collection.

<pre>

public class GCTest3 {
GCTest3 g;

   public static void main(String [] str){
GCTest3 gc1 = new GCTest3();
GCTest3 gc2 = new GCTest3();
gc1.g = gc2; //gc1 refers to gc2
gc2.g = gc1; //gc2 refers to gc1
gc1 = null;
gc2 = null;
//gc1 and gc2 refer to each other 
    //and have no other references
//gc1 and gc2 form Island of Isolation
//gc1 and gc2 are eligible for 
    //Garbage collection here
   }

}
</pre>]]></answer>
		</qa>
		<qa id="176" rating="2">			<question><![CDATA[q:Can the Garbage Collection be forced by any means?]]></question>
			<answer><![CDATA[No. The Garbage Collection can not be forced, though there are few ways by which it can be requested there is no guarantee that these requests will be taken care of by JVM.]]></answer>
		</qa>
		<qa id="177" rating="2">			<question><![CDATA[q:How can the Garbage Collection be requested?]]></question>
			<answer><![CDATA[There are two ways in which we can request the jvm to execute the Garbage Collection.
<pre>
1. Runtime.getRuntime().gc();
2. System.gc();
</pre>]]></answer>
		</qa>
		<qa id="178" rating="3">			<question><![CDATA[q:What is the purpose of overriding finalize() method?]]></question>
			<answer><![CDATA[The finalize() method should be overridden for an object to include the clean up code or to dispose of the system resources that should to be done before the object is garbage collected.]]></answer>
		</qa>
		<qa id="179" rating="2">			<question><![CDATA[q:If an object becomes eligible for Garbage Collection and its finalize() method has been called and inside this method the object becomes accessible by a live thread of execution and is not garbage collected. Later at some point the same object becomes eligible for Garbage collection, will the finalize() method be called again?]]></question>
			<answer><![CDATA[No]]></answer>
		</qa>
		<qa id="180" rating="2">			<question><![CDATA[q:How many times does the garbage collector call the finalize() method for an object?]]></question>
			<answer><![CDATA[Only once.]]></answer>
		</qa>
		<qa id="181" rating="3">			<question><![CDATA[q:What happens if an uncaught exception is thrown from during the execution of the finalize() method of an object?]]></question>
			<answer><![CDATA[The exception will be ignored and the garbage collection (finalization) of that object terminates.]]></answer>
		</qa>
		<qa id="182" rating="3">			<question><![CDATA[q:How to enable/disable call of finalize() method of exit of the application]]></question>
			<answer><![CDATA[Runtime.getRuntime().runFinalizersOnExit(boolean value) . Passing the boolean value will either disable or enable the finalize() call.]]></answer>
		</qa>
		<qa id="183" rating="3">			<question><![CDATA[q:What are the different types of references in java?]]></question>
			<answer><![CDATA[Java has a more expressive system of reference than most other garbage-collected programming languages, which allows for special behavior for garbage collection. A normal reference in Java is known as a strong reference. The java.lang.ref package defines three other types of references - soft, weak, and phantom references. Each type of reference is designed for a specific use.
<ul>
<li. <b>SoftReference</b> can be used to implement a cache. An object that is not reachable by a strong reference (that is, not strongly reachable), but is referenced by a soft reference is called softly reachable. A softly reachable object may be garbage collected at the discretion of the garbage collector. This generally means that softly reachable objects will only be garbage collected when free memory is low, but again, it is at the discretion of the garbage collector. Semantically, a soft reference means "keep this object unless the memory is needed."</li>

<li> <b>WeakReference</b> is used to implement weak maps. An object that is not strongly or softly reachable, but is referenced by a weak reference is called weakly reachable. A weakly reachable object will be garbage collected during the next collection cycle. This behavior is used in the class java.util.WeakHashMap. A weak map allows the programmer to put key/value pairs in the map and not worry about the objects taking up memory when the key is no longer reachable anywhere else. Another possible application of weak references is the string intern pool. Semantically, a weak reference means "get rid of this object when nothing else references it."</li>


<li><b>PhantomReference </b>is used to reference objects that have been marked for garbage collection and have been finalized, but have not yet been reclaimed. An object that is not strongly, softly or weakly reachable, but is referenced by a phantom reference is called phantom reachable. This allows for more flexible cleanup than is possible with the finalization mechanism alone. Semantically, a phantom reference means "this object is no longer needed and has been finalized in preparation for being collected."</li>
</ul>]]></answer>
		</qa>
		<qa id="184" rating="3">			<question><![CDATA[q:How to change the heap size of a JVM?]]></question>
			<answer><![CDATA[The old generation's default heap size can be overridden by using the -Xms and -Xmx switches to specify the initial and maximum sizes respectively: 
   java <b>-Xms[initial size] -Xmx[maximum size</b> program<br/>
Eg: java -Xms64m -Xmx128m program]]></answer>
		</qa>
	</category>
	<category name="Inner class">
		<qa id="185" rating="2">			<question><![CDATA[q: What is an inner class?]]></question>
			<answer><![CDATA[Inner class is a class defined inside other class and act like a member of the enclosing class.]]></answer>
		</qa>
		<qa id="186" rating="2">			<question><![CDATA[q: What are the different types of inner classes?]]></question>
			<answer><![CDATA[<ul>
<li>Static member class</li>
<li>Inner class</li>
<li>Member class</li>
<li>Anonymous class</li>
<li>Local class</li>
</ul>]]></answer>
		</qa>
		<qa id="187" rating="2">			<question><![CDATA[q: What is static member class?]]></question>
			<answer><![CDATA[A static member class behaves much like an ordinary top-level class, except that it can access the static members of the class that contains it. The static nested class can be accessed as the other static members of the enclosing class without having an instance of the outer class. The static class can contain non-static and static members and methods.
<pre>
public class InnerClass {
      static class StaticInner {
            static int i = 9; 
            int no = 6;
            private void method() {}
            public void method1() {}
            static void method2() {}
            final void method3() {}
      } 
}
</pre><br/>
      The static inner class can be accessed from Outer Class in the following manner -
<pre>
InnerClass.StaticInner staticObj= new InnerClass. StaticInner ();
</pre>
No outer class instance is required to instantiate the nested static class because the static class is a static member of the enclosing class.]]></answer>
		</qa>
		<qa id="188" rating="2">			<question><![CDATA[q: What are non static inner classes?]]></question>
			<answer><![CDATA[The different type of static inner classes are: 
<br/>
<b>Non - static inner classes</b> - classes associated with the object of the enclosing class. Member class - Classes declared outside a function (hence a "member") and not declared "static".
The member class can be declared as public, private, protected, final and abstract. E.g.
<pre>
public class InnerClass {
	class MemberClass {
		public void method1() { }
		} 
}
</pre><br/>
<b>Method local class</b> - The inner class declared inside the method is called method local inner class. Method local inner class can only be declared as final or abstract.	 Method local class can only access global variables or method local variables if declared as final
<pre>
public class InnerClass {

int i = 9;

public void method1() {
	final int k = 6; 
        class MethodLocal { 
		MethodLocal() { 
		S.o.p(k + i); 
  		} 
 	} 
  } 
}
</pre><br/>
<b>Anonymous inner class</b> - These are local classes which are automatically declared and instantiated in the middle of an expression.  Also, like local classes, anonymous classes cannot be public, private, protected, or static. They can specify arguments to the constructor of the superclass, but cannot otherwise have a constructor. They can implement only one interface or extend a class.<br/>
<b>Anonymous class cannot define any static fields, methods, or classes, except for static final constants.
Also, like local classes, anonymous classes cannot be public, private, protected, or static<br/>
Some examples:

<pre>

public class MyFrame extends JFrame {
        JButton btn = new JButton(); 
	MyFrame() { 
	btn.addActionListener(new ActionListener() { 
		public void actionPerformed(ActionEvent e) { 
		} 
	}); 
} 
}

Anonymous class used with comparator

List<Parent> l = new ArrayList<Parent>(); 
l.add(new Parent(2)); 
l.add(new Parent(3)); 

Collections.sort(l, new Comparator() { 
	public int compare(Object o1, Object o2) { 
		Parent prt1 = (Parent) o1; 
		Parent prt2 = (Parent) o2; 
		if (prt1.getAge() > prt2.getAge()) {
			return -1; 
		}else if(prt1.getAge()<prt2.getAge()) {
			return 1; 
		} else {
			return 0;
		} 
	} 
	});
</pre>]]></answer>
		</qa>
		<qa id="189" rating="2">			<question><![CDATA[q: Does a static nested class have access to the enclosing class' non-static methods or instance variables?]]></question>
			<answer><![CDATA[No .]]></answer>
		</qa>
		<qa id="190" rating="2">			<question><![CDATA[q:What are the advantages of Inner classes?]]></question>
			<answer><![CDATA[1. Nesting the inner class code where it is used (inside the outer class) makes the code more readable and maintainable.
The inner class shares a special relationship with the outer class i.e. the inner class has access to all members of the outer class and still have its own type is the main advantages of Inner class. <br/><br/>

2. Other Advantage of inner class is that they can be hidden from the other classes in the same package and still have the access to all the members (private also) of the enclosing class. So the outer class members which are going to be used by the inner class can be made private and the inner class members can be hidden from the classes in the same package. This increases the level of encapsulation.<br/><br/>

3.If a class A is written requires another class B for its own use, there are two ways to do this. One way is to write a separate class B or to write an inner class B inside class A. Advantage of writing the inner class B in the class A is you can avoid having a separate class. Inner classes are best used in the event handling mechanism and to implement the helper classes. <br/><br/>

4. The advantage of using inner class for event handling mechanism is that the use of if/else to select the component to be handled can be avoided. If inner classes are used each component gets its own event handler and each event handler implicitly knows the component it is working for. 

e.g. 
<pre>
Button btn1 = new Button("Submit"); 
Btn.addActionListener(new ActionListener(){

 Public void actionPerformed(ActionEvent ae){ 
	submitClicked(); 
 }
} 
);
</pre>

<br/><br/>

5. The advantage of using static nested class is that to instantiate a static nested class you need not create an instance of the enclosing class which reduces the number of objects the application creates at runtime.
</pre>]]></answer>
		</qa>
		<qa id="191" rating="2">			<question><![CDATA[q:What are disadvantages of using inner classes?]]></question>
			<answer><![CDATA[1. Using inner class increases the total number of classes being used by the application. For all the classes created by JVM and loaded in the memory, jvm has to perform some tasks like creating the object of type class. Jvm may have to perform some routine tasks for these extra classes created which may result slower performance if the application is using more number of inner classes.<br/><br/>
2. Inner classes get limited support of ide/tools as compared to the top level classes, so working with the inner classes is sometimes annoying for the developer.]]></answer>
		</qa>
		<qa id="192" rating="2">			<question><![CDATA[q: What are different types of anonymous classes?]]></question>
			<answer><![CDATA[1) Plain old anonymous class type one- <br/>
e.g. 
<pre>
class superClass{ 
         void doSomething() { 
           S.o.p("Super class"); 
         } 
 } 
class hasAnonymous{ 
     superClass anon = new superClass(){ 
       void doSomething() { 
	      S.o.p("Anonymous class"); 
     } 
   }; 
 </pre>
 
Here anon is the reference which is of type superClass which is the class extended by the anonymous class i.e. superclass of the anonymous class. The method doSomething() is the super class method overridden by the anonymous class. <br/><br/>
.
2) Plain old anonymous class type two - 
<pre>
interface Eatable{ 
       public void prepareSweets(); 
 } 
class serveMeal{ 
 Eatable food = new Eatable(){ 
              public void prepareSweets(){ //come implementation code goes here } 
     }; 
} 
</pre>
 food is reference variable of type Eatable interface which refers to the anonymous class which is the implementer of the interface Eatable. The anonymous implementer class of the interface Eatable implements its method prepareSweets() inside it. <br/><br/>
 
3) Argument defined anonymous class - 
e.g. 
<pre>

interface Vehicle { 
   void getNoOfWheels(); 
 } 

class Car { 
       void getType(Vehical v) { } 
} 

class BeautifulCars { 
  
  void getTheBeautifilCar() { 
     Car c = new Car (); 
     c.getType (new Vehicle () { 
	  public void getNoOfWheels () { 
		S.o.p("It has 4 wheels"); 
	  } 
     }); 
 }  
} 
 </pre><br/>
 Anonymous class is defined as the argument of the method getTheBeautifilCar(), this anonymous class is the implementer of the interface Vehicle. The method of class Car getTheBeautifilCar() expects the argument as an object of type Vehicle. So first we create an object of Car referenced by the variable 'c'. On this object of Car we call the method getTheBeautifilCar() and in the argument we create an anonymous class in place which is the implementer of interface Vehicle hence of type Vehicle.
</pre>]]></answer>
		</qa>
		<qa id="193" rating="2">			<question><![CDATA[q: If you compile a file containing inner class how many .class files are created and what are all of them accessible in usual way?]]></question>
			<answer><![CDATA[If a inner class enclosed with an outer class is compiled then one .class file for each inner class an a .class file for the outer class is created. e.g.
<pre>

class EnclosingOuter { 
    class Inner{ } 
 } 
</pre>
 If you compile the above code with command  <br/><br/>
% javac EnclosingOuter.java 
Two files <br/>
EnclosingOuter.class <br/>
EnclosingOuter$Inner.class <br/>
will be created. Though a separate inner class file is generated, the inner class file is not accessible in the usual way like, <br/>
% java EnclosingOuter$Inner<br/>]]></answer>
		</qa>
		<qa id="194" rating="2">			<question><![CDATA[q: How to access the inner class from code within the outer class?]]></question>
			<answer><![CDATA[The inner class is instantiated only through the outer class instance. 
<pre>

class EnclosingOuter { 

 int noInnerClass = 1; 

 public void getNoOfInnerClasses(){ 
  Inner in = new Inner(); 
  s.o.p("No Of Inner classes "+ in.getNoOfClassesFromOuter()); 
 } 

class Inner{ 
 public int getNoOfClassesFromOuter(){ 
  return noInnerClass; 
 } 
} 
</pre>
Here the method getNoOfInnerClasses() is called on the outer class's instance through this outer class instance the inner class instance in is created.]]></answer>
		</qa>
		<qa id="195" rating="2">			<question><![CDATA[q: How to create an inner class instance from outside the outer class instance code?]]></question>
			<answer><![CDATA[To create an instance of the inner class you must have the instance of its enclosing class. 
e.g. 
<pre> 
class EnclosingOuter { 
class Inner{ } 
}
</pre> 
 To create the instance of inner class from class other than the enclosing class. 
<pre> 

1) 
class OtherThanOuter{ 
  EnclosingOuter out = new EnclosingOuter(); 
  EnclosingOuter.Inner in = out.new Inner(); 
}

2) 
class OtherThanOuter{ 
  EnclosingOuter.Inner out = new EnclosingOuter.Inner (); 
}
</pre>]]></answer>
		</qa>
		<qa id="196" rating="2">			<question><![CDATA[q: How to refer to the outer this i.e. outer class's current instance from inside the inner class?]]></question>
			<answer><![CDATA[The outer this reference i.e. the outer class' current instance' reference can be refered using 'OuterClassName.this'. E.g 
 <pre>
 class EnclosingOuter { 
  class Inner{ 
 
   S.o.p("Inner class reference is " + this); 
   S.o.p("Outer class reference is " + EnclosingOuter.this); 
  } 
 } 
</pre>
To refer the inner class reference from within the inner class use this.]]></answer>
		</qa>
		<qa id="197" rating="2">			<question><![CDATA[q: Which modifiers can be applied to the inner class?]]></question>
			<answer><![CDATA[Following are modifiers that can be applied to the inner -  
 <ul>
<li>public </li>
<li>private </li>
<li>abstract </li>
<li>final </li>
<li>protected </li>
<li>strictfp </li>
<li>static - turns the inner class into static nested class.</li>
</ul>]]></answer>
		</qa>
		<qa id="198" rating="2">			<question><![CDATA[q: Can the method local inner class object access method's local variables?]]></question>
			<answer><![CDATA[No, a method local inner class object can not access the method local variable. 
Reason: The local variables are not guaranteed to live as long as the local inner class object. The method local variable live on stack and exist only till the method lives, their scope is limited only code inside the method they are declared in. But the local inner class object created within the method lives on heap and it may exist even after the method ends if in case the reference of this local inner class is passed into some other code and is stored in an instance variable. So we can not be sure that the local variables will live till the method local inner class object lives, therefore the method local inner class object can not access the method local variable. To access the method local variables, the variable has to be declared as final.]]></answer>
		</qa>
		<qa id="199" rating="2">			<question><![CDATA[q: Can a method local inner class access the local final variables?Why?]]></question>
			<answer><![CDATA[Yes. Because the final variables are stored on heap and they live as long as the method local inner class object may live.]]></answer>
		</qa>
		<qa id="200" rating="2">			<question><![CDATA[q: Which modifiers can be applied to the method local inner class?]]></question>
			<answer><![CDATA[Only abstract or final keyword isallowed.]]></answer>
		</qa>
		<qa id="201" rating="2">			<question><![CDATA[q: Can a local class declared inside a static method have access to the instance members of the outer class?]]></question>
			<answer><![CDATA[No. There is no this reference available in the static method .The static method class can not have access to any members of the outer class other than static members.]]></answer>
		</qa>
		<qa id="202" rating="2">			<question><![CDATA[q: Can a method which is not in the definition of the superclass of an anonymous class be invoked on that anonymous class reference?]]></question>
			<answer><![CDATA[No. Compilation will fail.As the reference variable type of the anonymous class will be of superclass which will not know of any method defined inside the anonymous class the compilation will fail. 
e.g. 
<pre>
class SuperClass{ 

     void doSomething() { 
	      S.o.p("In the Super class"); 
     } 
 } 
 
class hasAnonymous{ 

  SuperClass anon = new SuperClass(){ 

  void doSomething() { 
    S.o.p("In the Anonymous class"); 
  }

  void doStuff() { 
    S.o.p("class method not present in superClass"); 
  } 
 }; 
 
 public void doIt(){ 
  anon.doSomething(); // legal superClass has this method 
  anon.doStuff(); // Not legal 
 }
 
} 
</pre>
 The above code does not compile as the superClass does not know about the anonymous class method doStuff().]]></answer>
		</qa>
		<qa id="203" rating="2">			<question><![CDATA[q: Can an anonymous class define method of its own?]]></question>
			<answer><![CDATA[Yes. But there will be no way by which the methods defined in the anonymous class which are not present in its superclass be invoked. As only those methods which are defined in the suprclass which the anonymous class extends be invoked defining the methods in the anonymous class will be of no use.]]></answer>
		</qa>
		<qa id="204" rating="2">			<question><![CDATA[q: Can an anonymous class implement multiple interfaces directly?]]></question>
			<answer><![CDATA[No. An anonymous class can implement only one interface. If the anonymous class is extending a class then it becomes the implementer of all the interfaces implemented by its superclass automatically.]]></answer>
		</qa>
		<qa id="205" rating="2">			<question><![CDATA[q: Can an anonymous class implement an interface and also extend a class at the same time?]]></question>
			<answer><![CDATA[No. An anonymous class can either extend a class or implement a single interface. If the anonymous class is extending a class then it becomes the implementer of all the interfaces implemented by its superclass automatically.]]></answer>
		</qa>
	</category>
	<category name="JDK features">
		<qa id="206" rating="2">			<question><![CDATA[q:what are the new features of JDK 1.5 (tiger)]]></question>
			<answer><![CDATA[<pre>
I. Generics
II. Enhanced for Loop ("foreach")
III. Autoboxing/Unboxing
IV. Typesafe Enums
V. Varargs
VI. Static Import
VII. Metadata
</pre>
<a href="JDK5.pdf">More on JDK 5 features</a>]]></answer>
		</qa>
		<qa id="207" rating="2">			<question><![CDATA[q:what are the new features of JDK 1.6]]></question>
			<answer><![CDATA[<pre>
1. Scripting
2. Web Services
3. Database (JDBC 4.0, Java DB)
4. More Desktop APIs
5. Monitoring and Management
6. Compiler Access
7. Pluggable Annotations
8. Desktop Deployment
9. Security
10.Quality, Compatibility, Stability

</pre>
<a href="JDK6.pdf">More on JDK 6 features</a>]]></answer>
		</qa>
		<qa id="208" rating="2">			<question><![CDATA[q:JDK 7 Features]]></question>
			<answer><![CDATA[<pre>
1. Language
2. Annotations on Java types
3. Small language changes (Project Coin)
4. Modularity (JSR-294)
5. Core
6. Modularisation (Project Jigsaw)
7. Concurrency and collections updates
8. More new IO APIs (NIO.2)
9. Additional network protocol support
10. Eliptic curve cryptography
11. Unicode 5.1
</pre>
<a href="JDK7.pdf">More on JDK 7 features</a>]]></answer>
		</qa>
	</category>
	<category name="Serialization">
		<qa id="209" rating="2">			<question><![CDATA[q: What is Serializable?]]></question>
			<answer><![CDATA[Serializable is a marker interface. When an object has to be transferred over a network ( typically through rmi or EJB) or persist the state of an object to a file, the object Class needs to implement Serializable interface. Implementing this interface will allow the object converted into bytestream and transfer over a network.]]></answer>
		</qa>
		<qa id="210" rating="2">			<question><![CDATA[q: What is use of serialVersionUID?]]></question>
			<answer><![CDATA[During object serialization, the default Java serialization mechanism writes the metadata about the object, which includes the class name, field names and types, and superclass. This class definition is stored as a part of the serialized object. This stored metadata enables the deserialization process to reconstitute the objects and map the stream data into the class attributes with the appropriate type
Everytime an object is serialized the java serialization mechanism automatically computes a hash value. ObjectStreamClass's computeSerialVersionUID() method passes the class name, sorted member names, modifiers, and interfaces to the secure hash algorithm (SHA), which returns a hash value.The serialVersionUID is also called suid.<br/><br/>
So when the serilaize object is retrieved , the JVM first evaluates the suid of the serialized class and compares the suid value with the one of the object. If the suid values match then the object is said to be compatible with the class and hence it is de-serialized. If not InvalidClassException exception is thrown.<br/><br/>
Changes to a serializable class can be compatible or incompatible.]]></answer>
		</qa>
		<qa id="211" rating="2">			<question><![CDATA[q: What is the need of Serialization?]]></question>
			<answer><![CDATA[<ul>
<li>To send state of one or more object's state over the network through a socket.</li>
<li>To save the state of an object in a file.</li>
<li>An object's state needs to be manipulated as a stream of bytes.</li>
</ul>]]></answer>
		</qa>
		<qa id="212" rating="2">			<question><![CDATA[q: Other than Serialization what are the different approach to make object Serializable?]]></question>
			<answer><![CDATA[Besides the Serializable interface, at least three alternate approaches can serialize Java objects: <br/><br/>
1)For object serialization, instead of implementing the Serializable interface, a developer can implement the Externalizable interface, which extends Serializable. By implementing Externalizable, a developer is responsible for implementing the writeExternal() and readExternal() methods. As a result, a developer has sole control over reading and writing the serialized objects.<br/><br/>

2)XML serialization is an often-used approach for data interchange. This approach lags runtime performance when compared with Java serialization, both in terms of the size of the object and the processing time. With a speedier XML parser, the performance gap with respect to the processing time narrows. Nonetheless, XML serialization provides a more malleable solution when faced with changes in the serializable object.<br/><br/>

3)Finally, consider a "roll-your-own" serialization approach. You can write an object's content directly via either the ObjectOutputStream or the DataOutputStream. While this approach is more involved in its initial implementation, it offers the greatest flexibility and extensibility. In addition, this approach provides a performance advantage over Java serialization.]]></answer>
		</qa>
		<qa id="213" rating="2">			<question><![CDATA[q: Do we need to implement any method of Serializable interface to make an object serializable?]]></question>
			<answer><![CDATA[No. Serializable is a Marker Interface. It does not have any methods.]]></answer>
		</qa>
		<qa id="214" rating="2">			<question><![CDATA[q: What happens if the object to be serialized includes the references to other serializable objects?]]></question>
			<answer><![CDATA[If the object to be serialized includes the references to other objects whose class implements serializable then all those object's state also will be saved as the part of the serialized state of the object in question. The whole object graph of the object to be serialized will be saved during serialization automatically provided all the objects included in the object's graph are serializable.]]></answer>
		</qa>
		<qa id="215" rating="2">			<question><![CDATA[q: What happens if an object is serializable but it includes a reference to a non-serializable object?]]></question>
			<answer><![CDATA[If you try to serialize an object of a class which implements serializable, but the object includes a reference to an non-serializable class then a 'NotSerializableException' will be thrown at runtime.
<pre>
e.g.
public class NonSerial { 
    //This is a non-serializable class 
}
public class MyClass implements Serializable{ 
    private static final long serialVersionUID = 1L; 
    private NonSerial nonSerial; 
    MyClass(NonSerial nonSerial){ 
        this.nonSerial = nonSerial; 
    } 
    public static void main(String [] args) { 
        NonSerial nonSer = new NonSerial(); 
        MyClass c = new MyClass(nonSer); 
        try { 
        FileOutputStream fs = new FileOutputStream("test1.ser"); 
        ObjectOutputStream os = new ObjectOutputStream(fs); 
        os.writeObject(c); 
        os.close(); 
        } catch (Exception e) { e.printStackTrace(); } 
        try { 
        FileInputStream fis = new FileInputStream("test1.ser"); 
        ObjectInputStream ois = new ObjectInputStream(fis); 
        c = (MyClass) ois.readObject(); 
        ois.close(); 
            } catch (Exception e) { 
            e.printStackTrace(); 
          } 
    } 
}
</pre>
On execution of above code following exception will be thrown  -<br/>
java.io.NotSerializableException: NonSerial at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java)]]></answer>
		</qa>
		<qa id="216" rating="2">			<question><![CDATA[q: Are the static variables saved as the part of serialization?]]></question>
			<answer><![CDATA[No. The static variables belong to the class and not to an object they are not the part of the state of the object so they are not saved as the part of serialized object.]]></answer>
		</qa>
		<qa id="217" rating="2">			<question><![CDATA[q: What is a transient variable?]]></question>
			<answer><![CDATA[These variables are not included in the process of serialization and are not the part of the object's serialized state.]]></answer>
		</qa>
		<qa id="218" rating="2">			<question><![CDATA[q: What will be the value of transient variable after de-serialization?]]></question>
			<answer><![CDATA[It's default value.The transient variable is not saved as the part of the state of the serailized variable, it's value after de-serialization is it's default value.]]></answer>
		</qa>
		<qa id="219" rating="2">			<question><![CDATA[q: Does the order in which the value of the transient variables and the state of the object using the defaultWriteObject() method are saved during serialization matter?]]></question>
			<answer><![CDATA[Yes.  As while restoring the object's state the transient variables and the serializable variables that are stored must be restored in the same order in which they were saved.]]></answer>
		</qa>
		<qa id="220" rating="3">			<question><![CDATA[q: How can one customize the Serialization process? or What is the purpose of implementing the writeObject() and readObject() method?]]></question>
			<answer><![CDATA[When you want to store the transient variables state as a part of the serialized object at the time of serialization the class must implement the following methods -
<pre>
private void wrtiteObject(ObjectOutputStream outStream)
{
//save the transient variables state
}
private void readObject(ObjectInputStream inStream)
{
//read the transient variables state and assign it
// to de-serialized object
}
</pre>]]></answer>
		</qa>
		<qa id="221" rating="3">			<question><![CDATA[q: If a class is serializable but its superclass in not , what will be the state of the instance variables inherited  from super class after deserialization?]]></question>
			<answer><![CDATA[The values of the instance variables inherited from superclass will be reset to the values they were given during the original construction of the object as the non-serializable super-class constructor will run.]]></answer>
		</qa>
		<qa id="222" rating="2">			<question><![CDATA[q: To serialize an array or a collection all the members of it must be serializable. True /False?]]></question>
			<answer><![CDATA[true.]]></answer>
		</qa>
		<qa id="223" rating="2">			<question><![CDATA[q:  How many methods in the Serializable interface? Which methods of Serializable interface should I implement?]]></question>
			<answer><![CDATA[None. It's an empty marker interface which does not contain any methods. The Serializable interface acts as a marker, telling the object serialization tools that the class is serializable. So we do not implement any methods.]]></answer>
		</qa>
		<qa id="224" rating="2">			<question><![CDATA[q:  What is the difference between Serializalble and Externalizable interface? How can you control over the serialization process i.e. how can you customize the seralization process?]]></question>
			<answer><![CDATA[When you use Serializable interface, your class is serialized automatically by default. But you can override writeObject() and readObject() two methods to control more complex object serailization process. <br/><br/>
When you use Externalizable interface, you have a complete control over your class's serialization process. This interface contains two methods namely readExternal and writeExternal. You should implement these methods and write the logic for customizing the serialization process.]]></answer>
		</qa>
		<qa id="225" rating="2">			<question><![CDATA[q:  What interface must an object implement before it can be written to a stream as an object?]]></question>
			<answer><![CDATA[An object must implement the Serializable or Externalizable interface before it can be written to a stream as an object. The class whose instances are to be serialized should implement an interface Serializable. Then you pass the instance to the ObjectOutputStream which is connected to a fileoutputstream. This will save the object to a file.]]></answer>
		</qa>
		<qa id="226" rating="2">			<question><![CDATA[q:  What happens to the object references included in the object?]]></question>
			<answer><![CDATA[The serialization mechanism generates an object graph for serialization. Thus it determines whether the included object references are serializable or not. This is a recursive process. Thus when an object is serialized, all the included objects are also serialized alongwith the original object.]]></answer>
		</qa>
		<qa id="227" rating="2">			<question><![CDATA[q:  What is serialization?]]></question>
			<answer><![CDATA[The serialization is a kind of mechanism that makes a class or a bean persistent by having its properties or fields and state information saved and restored to and from storage. That is, it is a mechanism with which you can save the state of an object by converting it to a byte stream.]]></answer>
		</qa>
		<qa id="228" rating="2">			<question><![CDATA[q:  Common Usage of serialization.]]></question>
			<answer><![CDATA[Whenever an object is to be sent over the network or saved in a file, objects are serialized.]]></answer>
		</qa>
		<qa id="229" rating="2">			<question><![CDATA[q:  What happens to the static fields of a class during serialization?]]></question>
			<answer><![CDATA[There are three exceptions in which serialization doesn't necessarily read and write to the stream. These are 
 <ul>
 <li>Serialization ignores static fields, because they are not part of any particular state. </li>
 <li>Base class fields are only handled if the base class itself is serializable. </li>
 <li>Transient fields. </li>
</ul>]]></answer>
		</qa>
		<qa id="230" rating="2">			<question><![CDATA[q:  What one should take care of while serializing the object?]]></question>
			<answer><![CDATA[One should make sure that all the included objects are also serializable. If any of the objects is not serializable then it throws a NotSerializableException.]]></answer>
		</qa>
		<qa id="231" rating="2">			<question><![CDATA[q:  What is a transient variable? What are Transient and Volatile Modifiers]]></question>
			<answer><![CDATA[A transient variable is a variable that may not be serialized i.e. the value of the variable can't be written to the stream in a Serializable class. If you don't want some field to be serialized, you can mark that field transient or static. In such a case when the class is retrieved from the ObjectStream the value of the variable is null. <br/>
 Volatile modifier applies to variables only and it tells the compiler that the variable modified by volatile can be changed unexpectedly by other parts of the program.]]></answer>
		</qa>
		<qa id="232" rating="2">			<question><![CDATA[q: What is Serialization and deserialization?]]></question>
			<answer><![CDATA[Serialization is the process of writing the state of an object to a byte stream. Deserialization is the process of restoring these objects.]]></answer>
		</qa>
		<qa id="233" rating="2">			<question><![CDATA[q: What is Externalizable?]]></question>
			<answer><![CDATA[Externalizable is an interface which contains two methods readExternal and writeExternal. These methods give you a control over the serialization mechanism. Thus if your class implements this interface, you can customize the serialization process by implementing these methods.]]></answer>
		</qa>
	</category>
	<category name="Swing">
		<qa id="234" rating="2">			<question><![CDATA[q:  What is the difference between Swing and AWT components?]]></question>
			<answer><![CDATA[AWT components are heavy-weight, whereas Swing components are lightweight. Hence Swing works faster than AWT. Heavy weight components depend on the local windowing toolkit. For example, java.awt.Button is a heavy weight component. Pluggable look and feel possible using java Swing. Also, we can switch from one look and feel to another at runtime in swing which is not possible in AWT.]]></answer>
		</qa>
		<qa id="235" rating="2">			<question><![CDATA[q:  Name the containers which use Border Layout as their default layout?]]></question>
			<answer><![CDATA[window, Frame and Dialog classes. 
  Window, Frame, Dialog, FileDialog, Panel, Applet, or ScrollPane]]></answer>
		</qa>
		<qa id="236" rating="2">			<question><![CDATA[q: How can a GUI component handle its own events?]]></question>
			<answer><![CDATA[A component can handle its own events by implementing the required event-listener interface and adding itself as its own event listener.]]></answer>
		</qa>
		<qa id="237" rating="2">			<question><![CDATA[q: What is the difference between the paint() and repaint() methods?]]></question>
			<answer><![CDATA[The paint() method supports painting via a Graphics object. The repaint() method is used to cause paint() to be invoked by the AWT painting thread.]]></answer>
		</qa>
		<qa id="238" rating="2">			<question><![CDATA[q: Which package has light weight components?]]></question>
			<answer><![CDATA[javax.Swing package contains light weight components. All components in Swing, except JApplet, JDialog, JFrame and JWindow are lightweight components.]]></answer>
		</qa>
		<qa id="239" rating="2">			<question><![CDATA[q: What is a Container in a GUI?]]></question>
			<answer><![CDATA[A Container contains and arranges other components (including other containers) through the use of layout managers, which use specific layout policies to determine where components should go as a function of the size of the container.]]></answer>
		</qa>
		<qa id="240" rating="2">			<question><![CDATA[q: What is a layout manager and what are different types of layout managers available in java Swing?]]></question>
			<answer><![CDATA[A layout manager is an object that is used to organize components in a container. <br/>
The different layouts available are FlowLayout, BorderLayout, CardLayout, GridLayout and GridBagLayout. 

<ul>
<li>FlowLayout: The elements of a FlowLayout are organized in a top to bottom, left to right fashion. </li>
<li>BorderLayout: The elements of a BorderLayout are organized at the borders (North, South, East and West) and the center of a container. </li>
<li>CardLayout: The elements of a CardLayout are stacked, on top of the other, like a deck of cards. </li>
<li>GridLayout: The elements of a GridLayout are of equal size and are laid out using the square of a grid. </li>
<li>GridBagLayout: The elements of a GridBagLayout are organized according to a grid. However, the elements may be different sizes and may occupy more than one row or column of the grid. In addition, the rows and columns may have different sizes. </li>
</ul>]]></answer>
		</qa>
		<qa id="241" rating="2">			<question><![CDATA[q:  What advantage do Java's layout managers provide over traditional windowing systems?]]></question>
			<answer><![CDATA[Java uses layout managers to lay out components in a consistent manner across all windowing platforms. Since Java's layout managers aren't tied to absolute sizing and positioning, they are able to accommodate platform-specific differences among windowing systems.]]></answer>
		</qa>
		<qa id="242" rating="2">			<question><![CDATA[q:  What method is used to specify a container's layout?]]></question>
			<answer><![CDATA[The setLayout() method is used to specify a container's layout. For example, setLayout(new FlowLayout()); will be set the layout as FlowLayout.]]></answer>
		</qa>
		<qa id="243" rating="2">			<question><![CDATA[q:  Which Container method is used to cause a container to be laid out and redisplayed?]]></question>
			<answer><![CDATA[validate()]]></answer>
		</qa>
		<qa id="244" rating="2">			<question><![CDATA[q:  Name Component subclasses that support painting.]]></question>
			<answer><![CDATA[The Canvas, Frame, Panel, and Applet classes support painting.]]></answer>
		</qa>
		<qa id="245" rating="2">			<question><![CDATA[q:  What is the purpose of the enableEvents() method?]]></question>
			<answer><![CDATA[The enableEvents() method is used to enable an event for a particular component. Normally, an event is enabled when a listener is added to an object for a particular event. The enableEvents() method is used by objects that handle events by overriding their event-dispatch methods.]]></answer>
		</qa>
		<qa id="246" rating="2">			<question><![CDATA[q:  What is the difference between a Window and a Frame?]]></question>
			<answer><![CDATA[The Frame class extends Window to define a main application window that can have a menu bar.]]></answer>
		</qa>
		<qa id="247" rating="2">			<question><![CDATA[q:  What do heavy weight components mean?]]></question>
			<answer><![CDATA[Heavy weight components like Abstract Window Toolkit (AWT) depend on the local windowing toolkit. For example, java.awt .Button is a heavy weight component.]]></answer>
		</qa>
		<qa id="248" rating="2">			<question><![CDATA[q:  What is the difference between a Scrollbar and a ScrollPane?]]></question>
			<answer><![CDATA[A Scrollbar is just a Component, but not a Container. A ScrollPane is a Container. A ScrollPane handles its own events and performs its own scrolling.]]></answer>
		</qa>
		<qa id="249" rating="2">			<question><![CDATA[q:  What is the preferred size of a component?]]></question>
			<answer><![CDATA[The preferred size of a component is the minimum component size that will allow the component to display normally.]]></answer>
		</qa>
		<qa id="250" rating="2">			<question><![CDATA[q:  Which containers use a FlowLayout as their default layout?]]></question>
			<answer><![CDATA[The Panel and Applet classes use the FlowLayout as their default layout.]]></answer>
		</qa>
	</category>
	<category name="Threads">
		<qa id="251" rating="2">			<question><![CDATA[q:What is a Thread?]]></question>
			<answer><![CDATA[In Java, "thread" means two different things:

<ul>
<li>An instance of class java.lang.Thread.</li>
<li>A thread of execution.</li>
</ul>
<br/>

An instance of Thread is just an object. Like any other object in Java, it has variables and methods, and lives and dies on the heap. But a thread of execution is an individual process (a "lightweight" process) that has its own call stack. In Java, there is one thread per call stackor, to think of it in reverse, one call stack per thread. Even if you don't create any new threads in your program, threads are back there running. <br/><br/>

The main() method, that starts the whole ball rolling, runs in one thread, called (surprisingly) the main thread. If you looked at the main call stack (and you can, any time you get a stack trace from something that happens after main begins, but not within another thread), you'd see that main() is the first method on the stack the method at the bottom. But as soon as you create a new thread, a new stack materializes and methods called from that thread run in a call stack that's separate from the main() call stack.
<]]></answer>
		</qa>
		<qa id="252" rating="2">			<question><![CDATA[q:What is difference between thread and process?]]></question>
			<answer><![CDATA[<ol>
<li>Threads share the address space of the process that  created it; processes have their own address.</li>

<li>Threads have direct access to the data segment of its process; processes have their own copy of the data segment of the parent process.</li>

<li>Threads can directly communicate with other threads of its process; processes must use interprocess communication to communicate with sibling processes.</li>

<li>Threads have almost no overhead; processes have considerable overhead.</li>

<li>New threads are easily created; new processes require duplication of the parent process.</li>

<li>Threads can exercise considerable control over threads of the same process; processes can only exercise control over child processes.</li>

<li>Changes to the main thread (cancellation, priority change, etc.) may affect the behavior of the other threads of the process; changes to the parent process do not affect child processes.</li>
</ol>]]></answer>
		</qa>
		<qa id="253" rating="2">			<question><![CDATA[q:What are the different states of a thread's lifecycle?]]></question>
			<answer><![CDATA[<ul>
<li> <b>New</b> - When a thread is instantiated it is in New state until the start() method is called on the thread instance. In this state the thread is not considered to be alive. </li>
<li> <b>Runnable</b> - The thread enters into this state after the start method is called in the thread instance. The thread may enter into the Runnable state from Running state. In this state the thread is considered to be alive. </li>
<li> <b>Running</b> - When the thread scheduler picks up the thread from the Runnable thread's pool, the thread starts running and the thread is said to be in Running state.</li>
<li> <b>Waiting/Blocked/Sleeping</b> - In these states the thread is said to be alive but not runnable. The thread switches to this state because of reasons like wait method called or sleep method has been called on the running thread or thread might be waiting for some i/o resource so blocked.       Dead - When the thread finishes its execution i.e. the run() method execution completes, it is said to be in dead state. A dead state can not be started again. If a start() method is invoked on a dead thread a runtime exception will occur.</li>
</ul>]]></answer>
		</qa>
		<qa id="254" rating="2">			<question><![CDATA[q:What are the two ways of creating thread?]]></question>
			<answer><![CDATA[1. Extend the Thread class and override the run() method in your class. Create an instance of the subclass and invoke the start() method on it, which will create a new thread of execution. e.g.<br/>
<pre>

public class NewThread extends Thread{

 public void run(){ 
	// ...
 } 

 public static void main(String [] args){ 
  NewThread c = new NewThread(); 
  c.start(); 
 }

}
</pre>

2. Implements the Runnable interface.The class will have to implement the run() method in the Runnable interface. Create an instance of this class. Pass the reference of this instance to the Thread constructor a new thread of execution will be created. e.g. class

<pre>

public class NewThread implements Runnable{
 public void run(){ 
  //...
 } 

 public static void main(String [] args){ 
  NewThread c = new NewThread(); 
  Thread t = new Thread(c);
  t.start();
 }

}
</pre>]]></answer>
		</qa>
		<qa id="255" rating="2">			<question><![CDATA[q: What are different ways in which a thread can enter the waiting state?]]></question>
			<answer><![CDATA[A thread can enter the waiting state by the following ways: 
 <ol>
 <li> Invoking its sleep() method, </li>
 <li> By blocking on I/O </li>
 <li> By unsuccessfully attempting to acquire an object's lock </li>
 <li> By invoking an object's wait() method. </li>
 <li> It can also enter the waiting state by invoking its (deprecated) suspend() method.</li>
</ol>]]></answer>
		</qa>
		<qa id="256" rating="2">			<question><![CDATA[q:  What is the difference between yielding and sleeping?]]></question>
			<answer><![CDATA[When a task invokes its yield() method, it returns to the ready state, either from waiting, running or after its creation. When a task invokes its sleep() method, it returns to the waiting state from a running state.]]></answer>
		</qa>
		<qa id="257" rating="2">			<question><![CDATA[q: Extending Thread class or implementing Runnable Interface. Which is better?]]></question>
			<answer><![CDATA[You have two ways to do so. 
First, making your class "extends" Thread class. The other way is making your class implement "Runnable" interface. The latter is more advantageous, cause when you are going for multiple inheritance, then only interface can help. . If you are already inheriting a different class, then you have to go for Runnable Interface. Also, if you are implementing interface, it means you have to implement all methods in the interface.<br/><br/>

Both Thread class and Runnable interface are provided for convenience and use them as per the requirement. But if you are not extending any class, better extend Thread class as it will save few lines of coding. Otherwise performance wise, there is no distinguishable difference. A thread is in the ready state after it has been created and started.]]></answer>
		</qa>
		<qa id="258" rating="2">			<question><![CDATA[q: What is mutual exclusion? How can you take care of mutual exclusion using Java threads?]]></question>
			<answer><![CDATA[Mutual exclusion is a phenomenon where no two processes can access critical regions of memory at the same time. Using Java multithreading we can arrive at mutual exclusion. For mutual exclusion, you can simply use the synchronized keyword and explicitly or implicitly provide an Object, any Object, to synchronize on. The synchronized keyword can be applied to a class, to a method, or to a block of code.<br/><br/>
There are several methods in Java used for communicating mutually exclusive threads such as wait( ), notify( ), or notifyAll( ). For example, the notifyAll( ) method wakes up all threads that are in the wait list of an object.]]></answer>
		</qa>
		<qa id="259" rating="2">			<question><![CDATA[q: What is the difference between preemptive scheduling and time slicing?]]></question>
			<answer><![CDATA[Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then re-enters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.]]></answer>
		</qa>
		<qa id="260" rating="2">			<question><![CDATA[q: What invokes a thread's run() method?]]></question>
			<answer><![CDATA[After a thread is started, via its start() method of the Thread class, the JVM invokes the thread's run() method when the thread is initially executed.]]></answer>
		</qa>
		<qa id="261" rating="2">			<question><![CDATA[q: What is the purpose of the wait(), notify(), and notifyAll() methods?]]></question>
			<answer><![CDATA[The wait(), notify() and notifyAll() methods are used to provide an efficient way for thread inter-communication.]]></answer>
		</qa>
		<qa id="262" rating="2">			<question><![CDATA[q: What is thread? What are the high-level thread states? What are the states associated in the thread?]]></question>
			<answer><![CDATA[A thread is an independent path of execution in a system. The high-level thread states are ready, running, waiting and dead.]]></answer>
		</qa>
		<qa id="263" rating="2">			<question><![CDATA[q: What is deadlock?]]></question>
			<answer><![CDATA[When two threads are waiting for each other and can't proceed until the first thread obtains a lock on the other thread or vice versa, the program is said to be in a deadlock.]]></answer>
		</qa>
		<qa id="264" rating="2">			<question><![CDATA[q: How does multithreading take place on a computer with a single CPU?]]></question>
			<answer><![CDATA[The operating system's task scheduler allocates execution time to multiple tasks. By quickly switching between executing tasks, it creates the impression that tasks execute sequentially.]]></answer>
		</qa>
		<qa id="265" rating="2">			<question><![CDATA[q: What are synchronized methods and synchronized statements?]]></question>
			<answer><![CDATA[Synchronized methods are methods that are used to control access to an object. A thread only executes a synchronized method after it has acquired the lock for the method's object or class. Synchronized statements are similar to synchronized methods. A synchronized statement can only be executed after a thread has acquired the lock for the object or class referenced in the synchronized statement.]]></answer>
		</qa>
		<qa id="266" rating="2">			<question><![CDATA[q:What is a volatile keyword?]]></question>
			<answer><![CDATA[In general each thread has its own copy of variable, such that one thread is not concerned with the value of same variable in the other thread. But sometime this may not be the case. Consider a scenario in which the count variable is holding the number of times a method is called for a given class irrespective of any thread calling, in this case irrespective of thread access the count has to be increased so the count variable is declared as volatile. The copy of volatile variable is stored in the main memory, so every time a thread access the variable even for reading purpose the local copy is updated each time from the main memory.	
The volatile variable also have performance issues.]]></answer>
		</qa>
		<qa id="267" rating="2">			<question><![CDATA[q: Can Java object be locked down for exclusive use by a given thread? What happens when a thread cannot acquire a lock on an object?]]></question>
			<answer><![CDATA[Yes. You can lock an object by putting it in a "synchronized" block. The locked object is inaccessible to any thread other than the one that explicitly claimed it. If a thread attempts to execute a synchronized method or synchronized statement and is unable to acquire an object's lock, it enters the waiting state until the lock becomes available.]]></answer>
		</qa>
		<qa id="268" rating="2">			<question><![CDATA[q: What's the difference between the methods sleep() and wait()?]]></question>
			<answer><![CDATA[The sleep method is used when the thread has to be put aside for a fixed amount of time. Ex: sleep(1000), puts the thread aside for exactly one second. The wait method is used to put the thread aside for up to the specified time. It could wait for much lesser time if it receives a notify() or notifyAll() call. Ex: wait(1000), causes a wait of up to one second. The method wait() is defined in the Object and the method sleep() is defined in the class Thread.]]></answer>
		</qa>
		<qa id="269" rating="2">			<question><![CDATA[q: What is the difference between process and thread?]]></question>
			<answer><![CDATA[A thread is a separate path of execution in a program. A Process is a program in execution.]]></answer>
		</qa>
		<qa id="270" rating="2">			<question><![CDATA[q: What is daemon thread and which method is used to create the daemon thread?]]></question>
			<answer><![CDATA[Daemon threads are threads with low priority and runs in the back ground doing the garbage collection operation for the java runtime system. The setDaemon() method is used to create a daemon thread. These threads run without the intervention of the user. To determine if a thread is a daemon thread, use the accessor method isDaemon()  <br/><br/>
When a standalone application is run then as long as any user threads are active the JVM cannot terminate, otherwise the JVM terminates along with any daemon threads which might be active. Thus a daemon thread is at the mercy of the runtime system. Daemon threads exist only to serve user threads.]]></answer>
		</qa>
		<qa id="271" rating="2">			<question><![CDATA[q:  What do you understand by Synchronization?]]></question>
			<answer><![CDATA[With respect to multithreading, Synchronization is a process of controlling the access of shared resources by the multiple threads in such a manner that only one thread can access a particular resource at a time. In non synchronized multithreaded application, it is possible for one thread to modify a shared object while another thread is in the process of using or updating the object's value. Synchronization prevents such type of data corruption which may otherwise lead to dirty reads and significant errors. <br/>

 E.g. synchronizing a function: 

<pre>
 public synchronized void Method1 () { 
 // method code. 
 } 
 E.g. synchronizing a block of code inside a function: 
 public Method2 (){ 
 synchronized (this) { 
 // synchronized code here. 
 } 
 }
 </pre>]]></answer>
		</qa>
		<qa id="272" rating="2">			<question><![CDATA[q:  When  will you synchronize a piece of your code?]]></question>
			<answer><![CDATA[When you expect that your shared code will be accessed by different threads and these threads may change a particular data causing data corruption, then they are placed in a synchronized construct or a synchronized method.]]></answer>
		</qa>
		<qa id="273" rating="2">			<question><![CDATA[q:  Why would you use a synchronized block vs. synchronized method?]]></question>
			<answer><![CDATA[Synchronized blocks place locks for shorter periods than synchronized methods.]]></answer>
		</qa>
		<qa id="274" rating="An object's lock is a mechanism that is used by multiple threads to obtain synchronized access to the object. A thread may execute a synchronized method of an object only after it has acquired the object's lock. All objects and classes have locks. A class's lock is acquired on the class's Class object. 
r:2">			<question><![CDATA[q:  What is an object's lock and which objects have locks?]]></question>
			<answer><![CDATA[Answe]]></answer>
		</qa>
		<qa id="275" rating="2">			<question><![CDATA[q:  Can a lock be acquired on a class?]]></question>
			<answer><![CDATA[Yes, a lock can be acquired on a class. This lock is acquired on the class's Class object.]]></answer>
		</qa>
		<qa id="276" rating="2">			<question><![CDATA[q:  What state does a thread enter when it terminates its processing?]]></question>
			<answer><![CDATA[When a thread terminates its processing, it enters the dead state.]]></answer>
		</qa>
		<qa id="277" rating="2">			<question><![CDATA[q:  How would you implement a thread pool?]]></question>
			<answer><![CDATA[public class ThreadPool implements ThreadPoolInt <br/>

  This class is an generic implementation of a thread pool, which takes the following input <br/>
  a) Size of the pool to be constructed <br/>
  b) Name of the class which implements Runnable and constructs a thread pool with active threads that are waiting for activation. Once the threads have finished processing they come back and wait once again in the pool. <br/><br/>
  
This thread pool engine can be locked i.e. if some internal operation is performed on the pool then it is preferable that the thread engine be locked. Locking ensures that no new threads are issued by the engine. However, the currently executing threads are allowed to continue till they come back to the passivePool.]]></answer>
		</qa>
		<qa id="278" rating="2">			<question><![CDATA[q: Is there a separate stack for each thread in Java?]]></question>
			<answer><![CDATA[Yes. Every thread maintains its own separate stack, called Runtime Stack but they share the same memory. <br/><br/>Elements of the stack are the method invocations, called activation records or stack frame. The activation record contains pertinent information about a method like local variables.]]></answer>
		</qa>
		<qa id="279" rating="3">			<question><![CDATA[q:What is the difference between yield() and sleep()?]]></question>
			<answer><![CDATA[yield() allows the current the thread to release its lock from the object and scheduler gives the lock of the object to the other thread with same priority.<br/><br/>
  sleep() allows the thread to go to sleep state for x milliseconds. When a thread goes into sleep state it doesn't release the lock.]]></answer>
		</qa>
		<qa id="280" rating="2">			<question><![CDATA[q:What is the difference between wait() and sleep()?]]></question>
			<answer><![CDATA[1) wait() is a method of Object class. sleep() is a method of Object class.<br/><br/>

2) sleep() allows the thread to go to sleep state for x milliseconds. When a thread goes into sleep state it doesn't release the lock. wait() allows thread to release the lock and goes to suspended state. The thread is only active when a notify() or notifAll() method is called for the same object.]]></answer>
		</qa>
		<qa id="281" rating="2">			<question><![CDATA[q:What is difference between notify() and notfiyAll()?]]></question>
			<answer><![CDATA[notify( ) wakes up the first thread that called wait( ) on the same object. <br/><br/>
notifyAll( ) wakes up all the threads that called wait( ) on the same object. The highest priority thread will run first]]></answer>
		</qa>
		<qa id="282" rating="2">			<question><![CDATA[q:If a thread goes to sleep does it hold the lock?]]></question>
			<answer><![CDATA[Yes when a thread goes to sleep it does not release the lock.]]></answer>
		</qa>
		<qa id="283" rating="2">			<question><![CDATA[q:Can a thread hold multiple locks at the same time?]]></question>
			<answer><![CDATA[Yes. A thread can hold multiple locks at the same time. Once a thread acquires a lock and enters into the synchronized method / block, it may call another synchronized method and acquire a lock on another object.]]></answer>
		</qa>
		<qa id="284" rating="2">			<question><![CDATA[q:Can a thread call multiple synchronized methods on the object of which it hold the lock?]]></question>
			<answer><![CDATA[Yes. Once a thread acquires a lock in some object, it may call any other synchronized method of that same object using the lock that it already holds.]]></answer>
		</qa>
		<qa id="285" rating="2">			<question><![CDATA[q:Can static methods be synchronized?]]></question>
			<answer><![CDATA[Yes. As static methods are class methods and have only one copy of static data for the class, only one lock for the entire class is required. Every class in java is represented by java.lang.Class instance. The lock on this instance is used to synchronize the static methods.]]></answer>
		</qa>
		<qa id="286" rating="2">			<question><![CDATA[q:Can two threads call two different static synchronized methods of the same class?]]></question>
			<answer><![CDATA[No. The static synchronized methods of the same class always block each other as only one lock per class exists. So no two static synchronized methods can execute at the same time.]]></answer>
		</qa>
		<qa id="287" rating="2">			<question><![CDATA[q:Does a static synchronized method block a non-static synchronized method?]]></question>
			<answer><![CDATA[No As the thread executing the static synchronized method holds a lock on the class and the thread executing the non-satic synchronized method holds the lock on the object on which the method has been called, these two locks are different and these threads do not block each other.]]></answer>
		</qa>
		<qa id="288" rating="2">			<question><![CDATA[q:Once a thread has been started can it be started again?]]></question>
			<answer><![CDATA[No. Only a thread can be started only once in its lifetime. If you try starting a thread which has been already started once an IllegalThreadStateException is thrown, which is a runtime exception. A thread in runnable state or a dead thread can not be restarted.]]></answer>
		</qa>
		<qa id="289" rating="2">			<question><![CDATA[q:When does deadlock occur and how to avoid it?]]></question>
			<answer><![CDATA[When a locked object tries to access a locked object which is trying to access the first locked object. When the threads are waiting for each other to release the lock on a particular object, deadlock occurs .]]></answer>
		</qa>
		<qa id="290" rating="2">			<question><![CDATA[q:What is a better way of creating multithreaded application? Extending Thread class or implementing Runnable?]]></question>
			<answer><![CDATA[If a class is made to extend the thread class to have a multithreaded application then this subclass of Thread can not extend any other class and the required application will have to be added to this class as it can not be inherited from any other class. If a class is made to implement Runnable interface, then the class can extend other class or implement other interface.]]></answer>
		</qa>
		<qa id="291" rating="3">			<question><![CDATA[q:Can the start() method of the Thread class be overridden? If yes should it be overridden?]]></question>
			<answer><![CDATA[Yes the start() method can be overridden. But it should not be overridden as its implementation in thread class has the code to create a new executable thread and is specialised.]]></answer>
		</qa>
		<qa id="292" rating="2">			<question><![CDATA[q:What are the methods of the thread class used to schedule the threads?]]></question>
			<answer><![CDATA[The methods are as follows:
<pre>
public static void sleep(long millis) 
			throws InterruptedException 
			
public static void yield()

public final void join() throws InterruptedException 

public final void setPriority(int priority) 

public final void wait() throws InterruptedException 

public final void notify() 

public final void notifyAll()

</pre>]]></answer>
		</qa>
		<qa id="293" rating="2">			<question><![CDATA[q:Which thread related methods are available in Object class?]]></question>
			<answer><![CDATA[The methods are:
<pre>
public final void wait() throws Interrupted exception
public final void notify()
public final void notifyAll()
</pre>]]></answer>
		</qa>
		<qa id="294" rating="2">			<question><![CDATA[q:Which thread related methods are available in Thread class?]]></question>
			<answer><![CDATA[Methods which are mainly used :
<pre>
public static void sleep(long millis) throws Interrupted exception 
public static void yield() 
public final void join() throws Interrupted exception
public final void setPriority(int priority) 
public void start()
public void interrupt()
public final void join()
public void run()
public void resume()
</pre>]]></answer>
		</qa>
		<qa id="295" rating="2">			<question><![CDATA[q:List the methods which when called the thread does not release the locks held?]]></question>
			<answer><![CDATA[<pre>

notify()
join()
sleep()
yield()
</pre>]]></answer>
		</qa>
		<qa id="296" rating="2">			<question><![CDATA[q:List the methods which when called on the object the thread releases the locks held on that object?]]></question>
			<answer><![CDATA[wait()]]></answer>
		</qa>
		<qa id="297" rating="3">			<question><![CDATA[q:Does each thread has its own thread stack?]]></question>
			<answer><![CDATA[Yes each thread has its own call stack. For eg
<pre>
Thread t1 = new Thread();
Thread t2 = new Thread();
Thread t3 = t1;

</pre>
In the above example t1 and t3 will have the same stack and t2 will have its own independent stack.]]></answer>
		</qa>
		<qa id="298" rating="3">			<question><![CDATA[q:What is thread starvation?]]></question>
			<answer><![CDATA[In a multi-threaded environment thread starvation occurs if a low priority thread is not able to run or get a lock on the resoruce because of presence of many high priority threads. This is mainly possible by setting thread priorities inappropriately.]]></answer>
		</qa>
		<qa id="299" rating="3">			<question><![CDATA[q:What is threadLocal variable?]]></question>
			<answer><![CDATA[ThreadLocal is a class. If a variable is declared as threadLocal then each thread will have a its own copy of variable and would not interfere with the other's thread copy. Typical scenario to use this would be giving JDBc connection to each thread so that there is no conflict.

ThreadLocal class by JAVA API
<pre>
public class ThreadLocal { 
  public Object get();
  public void set(Object newValue);
  public Object initialValue();
}


Implementation of ThreadLocal
public class ConnectionDispenser { 
  private static class ThreadLocalConnection extends ThreadLocal { 
    public Object initialValue() { 
      return 
       DriverManager.getConnection(ConfigurationSingleton.getDbUrl()); 
    } 
  } 

  private static ThreadLocalConnection conn = new ThreadLocalConnection(); 

    public static Connection getConnection() { 
      return (Connection) conn.get(); 
    } 
  } 
  </pre>]]></answer>
		</qa>
	</category>
</questionbank>